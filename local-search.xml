<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识 Kotlin 函数式编程</title>
    <link href="/2024/03/24/intro%20to%20kotlin%20functional%20programming/"/>
    <url>/2024/03/24/intro%20to%20kotlin%20functional%20programming/</url>
    
    <content type="html"><![CDATA[<p>Kotlin 是一门与 Java 兼容、可在 JVM 上运行的编程语言，虽然 Kotlin 整体风格是类似与 Java 的面向对象，但它对函数式编程有非常好的支持。本文分享一些与函数式编程相关的 Kotlin 基础知识。大部分内容均来自 Kotlin 官方文档。</p><h3 id="Lambda-表达式与匿名函数"><a href="#Lambda-表达式与匿名函数" class="headerlink" title="Lambda 表达式与匿名函数"></a>Lambda 表达式与匿名函数</h3><p>在 Kotlin 中， lambda 表达式的语法非常简洁，我们可以省略很多冗余信息。</p><p>以下是一个基本示例，该 lambda 表达式接受两个参数并返回二者的和。在这行代码中，<code>sum</code> 的类型注解是不必要的，Kotlin 能够推断出 lambda 表达式的返回类型是 <code>Int</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br><span class="hljs-comment">// val sum = &#123;x: Int, y: Int -&gt; x + y&#125; 同样正确</span><br><span class="hljs-comment">// println(sum(1, 2)) // 3</span><br></code></pre></td></tr></table></figure><p>Lmabda 表达式常常用作参数，传递给高阶函数使用。当一个 lambda 表达式作为函数实参时，可以省略括号，将花括号写在外面。例如，我们可以使用 <code>any()</code> 来判断一组整数里是否包含偶数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; num: <span class="hljs-built_in">Int</span> -&gt; (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>若 lambda 表达式<strong>仅有一个参数</strong>，那么前面的 <code>-&gt;</code> 可以省略，并且 <code>it</code> 将指代那个参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; (it % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>匿名函数</strong>与 lambda 表达式类似，都用来定义 function literals。二者的主要区别在于匿名函数能够显式地指定返回类型，而 lambda 表达式则不能。lambda 表达式的返回类型只能依靠编译器推断。下面这个例子仍然是 <code>containsEven()</code> 函数，使用了匿名函数语法，不过这里的 <code>Boolean</code> 注解仍然是可以省略的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> isEven = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> collection.any(isEven)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>许多传统 OOP 语言要求函数必须在类内定义，而 Kotlin 则支持多种函数定义，包括：</p><ul><li>Top level function: 直接在文件定义，不依附于类</li><li>Local function: 在函数内定义</li><li>Member function: 在类或匿名类中定义</li><li>Extension function &amp; function with receiver: 在类外定义的函数，可以像使用成员函数一样调用</li></ul><p>Local function 就是函数里的函数。这样的函数能够访问外层函数的所有局部变量。如果将该函数作为返回值，那么将形成闭包 (closure)。这一特性也适用于 lambda 表达式和匿名函数。以下是一个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> ints = listOf(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;.forEach &#123; sum += it &#125;<br>print(sum) <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对列表里所有正数求和。这里的 lambda 表达式 <code>&#123; sum += it &#125;</code> 作为参数传给了 <code>forEach</code> 方法，它能够访问外部函数 <code>foo()</code> 的 local variable，得到正确的正数和。</p><p>另一个更复杂的例子来自 Kotlin 官方文档：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(graph: <span class="hljs-type">Graph</span>)</span></span> &#123; <br><span class="hljs-keyword">val</span> visited = HashSet&lt;Vertex&gt;() <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(current: <span class="hljs-type">Vertex</span>)</span></span> &#123; <br><span class="hljs-keyword">if</span> (!visited.add(current)) <span class="hljs-keyword">return</span> <br><span class="hljs-keyword">for</span> (v <span class="hljs-keyword">in</span> current.neighbors)<br>dfs(v) <br>&#125; <br>dfs(graph.vertices[<span class="hljs-number">0</span>]) <br>&#125;<br></code></pre></td></tr></table></figure><p>这里，内部的 <code>dfs()</code> 是一个递归函数，能够访问外部函数的参数 <code>graph</code>，并且可以对集合 <code>visited</code> 进行修改。</p><p>总而言之，<strong>Kotlin 中的内层函数可以访问到外层函数的局部变量，并且可以跨越多层嵌套访问。</strong></p><h3 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h3><p>Kotlin 使用 <code>return</code> 语句来从函数返回。返回值可以留空，空的返回值具有类型 <code>Unit</code>。在嵌套场景下，使用 <code>return</code> 语句的作用是 “returns from the nearest enclosing function or anonymous function”. 简而言之，它会从离它最近的使用 <code>fun</code> 定义的函数返回。</p><p>对于 lambda 表达式而言，情况则稍有不同。Kotlin 编译器会尝试推断 lambda 表达式的函数体是否不返回值，也就是返回值类型为 <code>Unit</code>，如果不是，那么函数体中的最后一个表达式会被自动返回。请看下面这两个 lambda 表达式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func1: () -&gt; <span class="hljs-built_in">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;This function returns nothing?&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> func2: () -&gt; <span class="hljs-built_in">Int</span> = &#123;<br>        println(<span class="hljs-string">&quot;This function return 3&quot;</span>)<br>        <span class="hljs-number">1</span> + <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到，<code>func1</code> 和 <code>func2</code> 都不接受参数，<code>func1</code> 不返回值，而 <code>func2</code> 将返回整数。</p><p>继续使用例子 <code>containsEven()</code>，我们在 <code>.any()</code> 中的 lambda 表达式添加一行打印语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; num -&gt;<br>            <span class="hljs-keyword">val</span> condition = ((num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>            println(<span class="hljs-string">&quot;Number <span class="hljs-variable">$num</span> : <span class="hljs-variable">$condition</span>&quot;</span>)<br>            condition<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里，lambda 表达式的最后一行 <code>condition</code> 会被返回。请注意，这里你不能用 <code>return condition</code> 从 lambda 表达式返回。因为，在 lambda 表达式里使用 <code>return</code> 会跳出 <code>containsEven()</code> 函数，这与预期的功能不符，虽然不会引起编译报错。</p><p>与 lambda 表达式不同的是，匿名函数可以正常使用 <code>return</code> 语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> isEven = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        println(num)<br>        <span class="hljs-keyword">return</span> (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> collection.any(isEven)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望从 lambda 表达式<strong>显式返回</strong>，我们需要特殊的语法 “return to labels”，以下是一个使用 lambda 表达式的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>    collection.any &#123; num -&gt;  <br>        <span class="hljs-keyword">val</span> condition = ((num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)  <br>        println(<span class="hljs-string">&quot;Number <span class="hljs-variable">$num</span> : <span class="hljs-variable">$condition</span>&quot;</span>)  <br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@any</span> condition  <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>高阶函数</strong> (high-order functions) 是将函数作为参数，或将函数作为返回值的函数。</p><p>Kotlin 标准库提供了众多高阶函数，它们能简化代码，提升可读性和可维护性。</p><p>假设你有一个可迭代的容器，里面有很多对象，你希望根据一系列逻辑筛选出符合条件的对象。你可能会写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> results = ArrayList&lt;Item&gt;()  <br><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> items) &#123;  <br>    <span class="hljs-keyword">val</span> condition: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-comment">// 进行一些操作来检查条件</span><br>    <span class="hljs-keyword">if</span> (condition) results.add(item)  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用标准库里的 <code>filter</code> 函数可以简化这样的代码。<code>filter</code> 函数接受一个函数作为参数，并返回一个列表，只包含判断为 true 的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> results = items.filter &#123;<br><span class="hljs-comment">// 使用 it 进行一些操作来检查条件</span><br>condition<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码所示，要使用 <code>filter</code> 函数，可以使用花括号快速创建一个 lambda 表达式。在函数体中，<code>it</code> 将指代 lambda 表达式的唯一参数，并且最后一行将作为返回值返回。</p><p>除此之外，Kotlin 还有许多高阶函数，包括 <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>fold</code>, <code>forEach</code>, <code>sortedBy</code> 等等。配合简洁的 lambda 表达式语法，它们能够简化各类对可迭代对象的操作。</p><h3 id="作用域函数"><a href="#作用域函数" class="headerlink" title="作用域函数"></a>作用域函数</h3><p>作用域函数 (scope functions) 是 Kotlin 提供的一组特殊的高阶函数，你可以在任意对象上调用作用域函数，就像调用成员函数一样。</p><blockquote><p>Kotlin 标准库提供了一些函数，它们用来围绕一个对象执行一段代码块。当你在对象上调用这样的函数，并提供了一个 lambda 表达式时，它形成一个临时作用域。在此作用域中，你可以在不使用对象名称的情况下访问该对象。此类函数称为作用域函数 (scope functions)。共有五个作用域函数：let、run、with、apply 和 also。</p></blockquote><p>上面这段话是 Kotlin 官方对 scope function 的介绍（从英文翻译），是不是很迷糊？我们来看一个例子，该例子使用 <code>StringBuilder</code> 来根据一些数据创建一个字符串。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> builder = StringBuilder()<br>    <span class="hljs-comment">// 从 1 到 10 的字符串</span><br>    builder.append(<span class="hljs-string">&quot;Numbers: &quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) &#123;<br>        builder.append(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> resultString = builder.toString()<br>    println(resultString)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>for</code> 循环可能代表实际代码里的数据处理。在这段代码中，局部变量名称 <code>builder</code> 被重复了很多次，这很繁琐且不美观。我们可以使用函数式编程来改进这段代码的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    StringBuilder().apply &#123;<br>        append(<span class="hljs-string">&quot;Numbers: &quot;</span>)<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) &#123; <br>            append(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <br>        &#125; <br>    &#125;.toString().let &#123;<br>        println(it)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这个 <code>StringBuilder</code> 对象上调用了作用域函数 <code>apply</code>，它接收一个 lambda 表达式。在 lambda 表达式中，我们可以使用 <code>this</code> 来指代原对象，更可以省略 <code>this</code>。我们在结果字符串上继续调用作用域函数 <code>let</code>，并在随后的 lambda 表达式中用参数 <code>it</code> 指代字符串对象。于是，我们就避免了局部变量 <code>builder</code> 和 <code>resultString</code>，从而使代码更加简洁。</p><p>作用域函数的实现方式也非常简单，比如下面这个函数就实现了类似于标准库 <code>apply()</code> 的功能。它用到了 generic function 和 function with receiver 语法，这样允许我们在任何对象上调用它。它接受的参数也是一个 function with receiver，这样就允许我们在 lambda 表达式里使用 <code>this</code> 来指代原对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//                 这里是输入函数的类型</span><br><span class="hljs-comment">//                   ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">myApply</span><span class="hljs-params">(f: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    <span class="hljs-keyword">this</span>.f()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最为相像的四个作用域函数是 <code>let</code>, <code>run</code>, <code>apply</code>, 和 <code>also</code>. 作为扩展函数，它们可以在任意对象上调用，区分它们的要点是：</p><ol><li>是否需要返回对象本身？是否需要返回其他任意值？<code>let</code> 和 <code>run</code> 函数会返回 lambda 表达式的结果，而 <code>apply</code> 和 <code>also</code> 会返回对象本身。</li><li>使用什么引用对象？<code>let</code> 和 <code>also</code> 创造的作用域里使用 <code>it</code> 指代对象，而 <code>apply</code> 和 <code>run</code> 创造的作用域里使用 <code>this</code> 指代对象。</li></ol><p>最后，<code>with</code> 不是一个扩展函数，你需要将对象作为参数传递给它。</p><p>作用域函数的对比表格如下。</p><table><thead><tr><th>Function</th><th>Object reference</th><th>Return value</th><th>Is extension function</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html"><code>let</code></a></td><td><code>it</code></td><td>Lambda result</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html"><code>run</code></a></td><td><code>this</code></td><td>Lambda result</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html"><code>apply</code></a></td><td><code>this</code></td><td>Context object</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html"><code>also</code></a></td><td><code>it</code></td><td>Context object</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html"><code>run</code></a></td><td>-</td><td>Lambda result</td><td>No: called without the context object</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html"><code>with</code></a></td><td><code>this</code></td><td>Lambda result</td><td>No: takes the context object as an argument</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Networkx 中一个引起歧义的参数</title>
    <link href="/2024/02/21/nbunch%20in%20networkx/"/>
    <url>/2024/02/21/nbunch%20in%20networkx/</url>
    
    <content type="html"><![CDATA[<p>安静的夜晚，正准备拉满生产力的我被一个 bug 无情打断。我正在编写一些平凡的数据处理脚本，为了<del>偷懒</del>不重复造轮子，我使用了我并不熟悉的 Python 库 —— networkx. 当我发现处理后的数据和原始数据有不一致的时候，我意识到我写了一个 bug。一番调试之后，我发现这个 bug 来自于一个 API 没有按我猜测的方式工作。</p><p>下面用一个小例子展示一下这个 API 的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx<br>test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>), (<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;101&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>这一行代码使用 networkx 库创建了一个有向图，其节点用字符串表示，初始包含三条边。</p><p>然后，我希望查询某个特定节点的所有出边，通过简单查阅文档，发现了 <code>DiGraph</code> 对象有一个名为 <code>edges</code> 的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># [(&#x27;100&#x27;, &#x27;101&#x27;)]</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;999&#x27;</span>)) <span class="hljs-comment"># []</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;129&#x27;</span>)) <span class="hljs-comment"># [(&#x27;1&#x27;, &#x27;2&#x27;), (&#x27;2&#x27;, &#x27;3&#x27;)]</span><br></code></pre></td></tr></table></figure><p>当填入参数 <code>&#39;100&#39;</code> 时，正确返回了那条以 100 为起始点的边；当填入参数 <code>&#39;999&#39;</code> 时，由于图中没有这个节点，所以返回了一个空列表；当填入参数 <code>&#39;129&#39;</code> 时，它却返回了看似不相干的边。</p><p>这是为什么？？？</p><p>仔细阅读 <code>Digraph.edges</code> 的文档：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;&quot;&quot;An OutEdgeView of the DiGraph as G.edges or G.edges().<br><br>        edges(self, nbunch=None, data=False, default=None)<br><br>        The OutEdgeView provides set-like operations on the edge-tuples<br>        as well as edge attribute lookup. When called, it also provides<br>        an EdgeDataView object which allows control of access to edge<br>        attributes (but does not provide set-like operations).<br>        Hence, `G.edges[u, v][&#x27;color&#x27;]` provides the value of the color<br>        attribute for edge `(u, v)` while<br>        `for (u, v, c) in G.edges.data(&#x27;color&#x27;, default=&#x27;red&#x27;):`<br>        iterates through all the edges yielding the color attribute<br>        with default `&#x27;red&#x27;` if no color attribute exists.<br><br>        Parameters<br>        ----------<br>        nbunch : single node, container, or all nodes (default= all nodes)<br>            The view will only report edges from these nodes.<br>        data : string or bool, optional (default=False)<br>            The edge attribute returned in 3-tuple (u, v, ddict[data]).<br>            If True, return edge attribute dict in 3-tuple (u, v, ddict).<br>            If False, return 2-tuple (u, v).<br>        default : value, optional (default=None)<br>            Value used for edges that don&#x27;t have the requested attribute.<br>            Only relevant if data is not True or False.<br><br>        Returns<br>        -------<br>        edges : OutEdgeView<br>            A view of edge attributes, usually it iterates over (u, v)<br>            or (u, v, d) tuples of edges, but can also be used for<br>            attribute lookup as `edges[u, v][&#x27;foo&#x27;]`.<br><br>        See Also<br>        --------<br>        in_edges, out_edges<br><br>        Notes<br>        -----<br>        Nodes in nbunch that are not in the graph will be (quietly) ignored.<br>        For directed graphs this returns the out-edges.<br><br>        Examples<br>        --------<br>        &gt;&gt;&gt; G = nx.DiGraph()  # or MultiDiGraph, etc<br>        &gt;&gt;&gt; nx.add_path(G, [0, 1, 2])<br>        &gt;&gt;&gt; G.add_edge(2, 3, weight=5)<br>        &gt;&gt;&gt; [e for e in G.edges]<br>        [(0, 1), (1, 2), (2, 3)]<br>        &gt;&gt;&gt; G.edges.data()  # default data is &#123;&#125; (empty dict)<br>        OutEdgeDataView([(0, 1, &#123;&#125;), (1, 2, &#123;&#125;), (2, 3, &#123;&#x27;weight&#x27;: 5&#125;)])<br>        &gt;&gt;&gt; G.edges.data(&quot;weight&quot;, default=1)<br>        OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])<br>        &gt;&gt;&gt; G.edges([0, 2])  # only edges originating from these nodes<br>        OutEdgeDataView([(0, 1), (2, 3)])<br>        &gt;&gt;&gt; G.edges(0)  # only edges from node 0<br>        OutEdgeDataView([(0, 1)])<br><br>        &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>文档表明，当我们给 <code>edges</code> 传 1 个参数时，它实际上是 <code>nbunch</code>，顾名思义，这个 <code>nbunch</code> 就是 a bunch of nodes 一堆节点，它既可以是一个节点，也可以是一个节点的容器，如果不提供参数它将默认为所有节点。在后面的 examples 中，文档展示 <code>G.edges([0, 2])</code> 和 <code>G.edges(0)</code> 两种用法。在 notes 中，文档也提醒我们，不存在的节点会被 quietly ingnored。</p><p>作为历史悠久的 Python 库，networkx 自然是充分利用 Python 的动态特性，并且没有提供任何类型标注，用户并不知道传入 <code>edges</code> 的 <code>nbunch</code> 参数会被当做什么类型。而这个 bug 的原因也非常简单，networkx 库把我们传入的 <code>&#39;129&#39;</code> 当成了一个 iterable 的对象，并试图找到节点 <code>[&#39;1&#39;, &#39;2&#39;, &#39;9&#39;]</code> 为起始的所有边。</p><p>查阅 networkx 的源码，你会发现它没有做任何错事：参数 <code>nbunch</code> 经过 <code>Graph.nbunch_iter()</code> 处理为了一个 iterator，该函数简单地判断 <code>nbunch</code> 是不是当前图里的节点，如果是就返回 <code>iter([nbunch])</code>，如果不是就当成一个节点序列处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nbunch_iter</span>(<span class="hljs-params">self, nbunch=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> nbunch <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># include all nodes via iterator</span><br>        bunch = <span class="hljs-built_in">iter</span>(self._adj)<br>    <span class="hljs-keyword">elif</span> nbunch <span class="hljs-keyword">in</span> self:  <span class="hljs-comment"># if nbunch is a single node</span><br>        bunch = <span class="hljs-built_in">iter</span>([nbunch])<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># if nbunch is a sequence of nodes</span><br>        ...<br>    <span class="hljs-keyword">return</span> bunch<br></code></pre></td></tr></table></figure><p>我想不到这段代码本身有任何问题。但是，当一个对象既可以是一个节点，也有可能是一个可迭代的节点序列，那么这样的 API 调用就是有歧义的。甚至，有向图的点集会影响该 API 的行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)])<br><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># [(&#x27;1&#x27;, &#x27;2&#x27;)]</span><br><br>test_graph.add_nodes_from([<span class="hljs-string">&#x27;100&#x27;</span>]) <span class="hljs-comment"># 仅新增一个节点 不改变原边集</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure><p>想要修复也非常简单，只需要手工传入一个长度为 1 的列表即可避免歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)])<br><span class="hljs-built_in">print</span>(test_graph.edges([<span class="hljs-string">&#x27;100&#x27;</span>])) <span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure><p>回顾一下这个问题：networkx 在设计之初就借助 Python 的动态特性让它们的 API 尽可能灵活适应不同情况，没有对输入参数的类型进行限制。当用户调用 <code>DiGraph.edges</code> 时，该 API 将输入参数 <code>nbunch</code> 视为何种数据类型由有向图的节点集决定（如果 <code>nbunch</code> 不在点集中则被将视为可迭代对象），在一些情况下，API 的行为和用户的预期产生了偏差，最终导致了隐蔽的 bug。</p><p>实际上，关于 <code>nbunch</code> 参数的歧义，GitHub 社区已经有多个讨论，比如 <a href="https://github.com/networkx/networkx/issues/4781">#4871</a> ， <a href="https://github.com/networkx/networkx/issues/6509">#6509</a> 和 <a href="https://github.com/networkx/networkx/issues/6275">#6275</a> ，社区贡献者也曾积极讨论这个问题，但至今没有引起代码的更改。如果你作为 networkx 的熟练使用者，你很清楚 networkx 会怎么处理 <code>nbunch</code> 参数值，你自然不会写出像 <code>test_graph.edges(node)</code> 的歧义语句。但如果你作为刚刚接触 networkx 的人（就像我一样），则很有可能像我一样直接把节点对象传给该 API。到底要不要为了这个罕见问题修改 networkx 源码，社区开发者最终选择了保持不变。</p><p>那么这样的 bug 该怎么预防呢？或者说，究竟怎么修改 networkx 的代码才能避免这样的潜在 bug 呢？</p><ol><li>加入额外的逻辑判断传入的参数到底是节点序列还是单个节点。然而这是不可能的，因为 networkx 认为所有 hashable 的对象都可以作为节点，并且 networkx 不提供任何节点的基类，并不存在 <code>isinstance(node, BaseNode)</code> 之类的操作。同我们最开始展示的例子，一个 string 既是 hashable 也是 iterable，你没办法仅从数据类型进行判断。</li><li>让 <code>nbunch_iter</code> 只接受 <code>nbunch</code> 是 iterable 对象。这并不会牺牲灵活性，因为当你想传入单个节点时，只需要把它放在一个 list 里就行了。但是这会修改 API，影响到 networkx 库里其他所有用到 <code>nbunch_iter</code> 的地方。</li></ol><p>最终，社区开发者在 <a href="https://github.com/networkx/networkx/pull/6513">这个 PR</a> 里为文档增加了额外的例子来解释 <code>nbunch</code> 可能引起的歧义，而并没有引起代码变更。然而，增加的额外解释藏在 <a href="https://networkx.org/documentation/stable/reference/glossary.html#term-nbunch">Glossary 板块里</a>，极不容易被注意到……</p><p>总而言之，<code>nbunch</code> 的故事就是一个典型的牺牲可靠性获得灵活性的例子，如果 networkx 在设计之初就考虑了 gradual typing，那么 <code>nbunch_iter()</code> 的作者自然不会写出像 <code>Hashable | Iterable[Hashable] | None</code> 或者像 <code>Optional[Union[Hashable, Iterable[Hashable]]]</code> (Python 3.10 之前) 这么奇怪的类型标注，从而在最一开始就把 <code>nbunch</code> 设计为只接受节点序列。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自动化的博客发布工作流</title>
    <link href="/2024/01/12/My%20Blog%20Workflow/"/>
    <url>/2024/01/12/My%20Blog%20Workflow/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>23 年 10 月份，我开始使用 Obsidian 作为笔记工具，从此一发不可收拾。之前氪金支持的 Typora，现在已沦为 Markdown 本地预览器。我进一步发现，Obsidian 透明可定制的设计理念，使它可以与其他工具进行集成和协同，堪称是笔记届的 VSCode。经过 2 天左右的尝试，我就搞出了一套使用 Obsidian 撰写文章并自动发布到网站的工作流，整个过程门槛极低，并且有很不错的自定义空间（假设你非常熟悉前端技术）。现在把这套工具和流程分享给大家。</p><p>目前我使用的工具如下。</p><ul><li><a href="https://docs.github.com/en/pages/quickstart">GitHub Pages</a>: 免费的静态网站部署，大陆可访问</li><li><a href="https://hexo.io/">Hexo</a>: 一个基于 Nodejs 的静态网站生成器，文章使用 Markdown 作为源语言</li><li><a href="https://obsidian.md/">Obsidian</a>: 高度自定义的笔记工具，内容完全基于 Markdown 文件</li><li><a href="https://github.com/denolehov/obsidian-git">Obsidian-Git</a> 插件: 免费的云端备份和跨设备同步解决方案，基于 Git</li></ul><div class="note note-info">            <p>这里一共涉及了三个概念，分别是笔记工具 (编辑 Markdown)、静态网站生成器 (处理 Markdown)、网站部署服务。它们相互独立，分别可以用其他工具替换。本文主要展示我比较喜欢的这一组合。</p>          </div><p>借助这些工具，我们可以在 Obsidian 内随心编写内容，然后自动地将文章发布至网站，并且不会产生任何费用。经过前期的配置后，发布一篇博文真的就<strong>只需要三步</strong>：</p><ol><li>在 Obsidian 里新建文件，填入标题等信息，并在 Obsidian 内完成撰写</li><li>打开命令行执行 <code>hexo deploy -g</code></li><li>等待 GitHub Pages 部署完成，即可在网站上看到精美的文章</li></ol><p>接下来，我简要介绍一下我的配置过程。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了在机器上顺利运行 Hexo 和 Git 等命令行工具，需要提前做以下准备：</p><ol><li>Nodejs. 由于 Hexo 是基于 JavaScript 的工具，需要在自己的机器上安装 node 和 npm&#x2F;pnpm 等命令行工具，Windows 可使用 scoop&#x2F;winget (类似于 Ubuntu 中的 apt) 安装。</li><li>Git. 通过本地的 Git 命令行工具能够直接 pull&#x2F;push 远程仓库，避免手动上传下载。</li><li>GitHub &#x2F; Gitee 等平台账号。<ul><li>我使用 GitHub Pages 作为静态页面部署方案，</li><li>我使用 Gitee 私有仓来托管源码项目，它兼具云端备份和跨设备同步的功能，所以希望网络连接通畅一些，换成 GitHub 也是完全一样的。</li></ul></li></ol><h2 id="Hexo-项目配置"><a href="#Hexo-项目配置" class="headerlink" title="Hexo 项目配置"></a>Hexo 项目配置</h2><p>Hexo 是一个博客站框架，准确的来说，它是一个静态网站生成器，类似于 Jekyll。它负责将一个文件夹 (默认为 <code>source/_posts</code>) 下的所有 Markdown 文件转化为一个网站。关于 Hexo 的用法，可以查阅 <a href="https://hexo.io/docs/">文档</a>。</p><h3 id="创建网站"><a href="#创建网站" class="headerlink" title="创建网站"></a>创建网站</h3><p>首先 clone 官方提供的项目模板到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/hexojs/hexo-starter blog<br></code></pre></td></tr></table></figure><p>进入该路径后，你将会看到：</p><ul><li><code>source/</code> 是存放网站源内容的目录，Hexo 不会修改该目录下的任何内容。准确地来说，该目录中的 Markdown 后缀文件会被 Hexo 识别并处理，其余文件将会照搬至网站文件中。<ul><li><code>source/_posts</code> 中的所有 Markdown 文件将被视作文章，在 Obsidian 中，我们在该文件下创建的笔记将被发布，否则不会被处理为文章。</li></ul></li><li><code>_config.yml</code> 是网站配置，可以根据 <a href="https://hexo.io/docs/configuration">文档</a> 来修改。</li><li><code>themes/</code> 是安装第三方主题的地方。</li><li><code>.gitignore</code> 指定 Git 不会追踪的文件。</li></ul><p>这个目录同时作为 Hexo 项目和 Obsidian Vault，我希望这个目录在我的所有设备之间同步，所以我希望 Git 不要追踪 Node 依赖、Hexo 部署产生的临时文件。这是我的 <code>.gitignore</code> 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gitignore"># Node<br>*.log<br>*.iml<br>node_modules/<br>package-lock.json<br>*.lock<br>pnpm-lock.yaml<br><br># Obsidian<br>.obsidian/workspace.json<br>.obsidian/workspace-mobile.json<br>.obsidian/community-plugins.json<br>.obsidian/plugins/<br><br># Hexo<br>db.json<br>public/<br>.deploy_git/<br></code></pre></td></tr></table></figure><p>在该目录下，使用你喜欢的包管理工具安装依赖，这样你就可以在这个目录下使用 Hexo 命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install<br>npx hexo --version<br></code></pre></td></tr></table></figure><p>至此，你就可以随意使用 Hexo 了。例如你可以使用 <code>hexo generate</code> 来生成整个网站，或者直接使用 <code>hexo server</code> 来在本地浏览器查看网站。在本地查看过程中，你在 <code>source/_posts</code> 修改的文章内容都会立刻生效（浏览器刷新网页）。</p><h3 id="静态网站部署"><a href="#静态网站部署" class="headerlink" title="静态网站部署"></a>静态网站部署</h3><p>接下来，我们可以将 Hexo 生成的网站部署到网上，让其他人都可以看到。使用 GitHub Pages 部署静态网站非常简单，你只需要把网站内容上传到 <code>&lt;username&gt;.github.io</code> 这个仓库，就等同于部署到 <code>https://&lt;username&gt;.github.io</code> 这个网站。</p><p>插件 hexo-deployer-git 可以将上传的流程自动化。首先在该目录下安装 node 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-deployer-git<br></code></pre></td></tr></table></figure><p>然后在 <code>_config.yml</code> 中填入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;username&gt;/&lt;username&gt;.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><p>这个意思是，告诉 Hexo 你的部署方式是通过 Git 上传到一个你指定的远程仓库。</p><p>前往 GitHub 官网创建一个名为 <code>&lt;username&gt;.github.io</code> 的公开仓库，并参考 <a href="https://docs.github.com/en/pages/quickstart">官方教程</a> 在仓库里设置 Pages 服务，然后你就可以使用 <code>hexo deploy</code> 命令自动上传。一旦你把网站内容传到 GitHub，GitHub Pages 会自动地部署你的内容。</p><h2 id="Obsidian-Vault-配置"><a href="#Obsidian-Vault-配置" class="headerlink" title="Obsidian Vault 配置"></a>Obsidian Vault 配置</h2><p>刚刚讲到，Hexo 本质上就是把 <code>source/_posts</code> 下的所有 Markdown 文件当做文章，并根据它们生成网站。这与 Obsidian 的使用理念高度统一，Obsidian 本质上就是帮助你编辑一个文件夹 (称为 Vault) 下的所有 Markdown 文件。</p><p>我们打开 Obsidian，点击 Open Folder as Vault 并选择我们刚刚创建的目录。这样，Obsidian 会在项目目录下创建一个名为 <code>.obsidian</code> 的文件夹，存放该 Vault 的设置、插件等信息，类似于 <code>.idea/</code> 和 <code>.vscode/</code>。没有特殊情况的话，该文件夹可以让 Git 追踪并同步，不过为了防止潜在的合并冲突，我推荐在 <code>.gitignore</code> 里忽略以下两项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gitignore">.obsidian/workspace.json<br>.obsidian/plugins/<br></code></pre></td></tr></table></figure><h3 id="文章模版"><a href="#文章模版" class="headerlink" title="文章模版"></a>文章模版</h3><p>在 Hexo 中，每个 Markdown 文件都需要通过 front-matter 来指定文章的元信息，一个典型的 front-matter 是这个样子的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;文章标题&quot;</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2024-01-11 11:22:56</span><br><span class="hljs-attr">updated:</span> <span class="hljs-number">2024-01-11 11:22:56</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">文章</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>这些内容会被 Hexo 解析，用于生成网站。完整的设置字段请查阅 <a href="https://hexo.io/docs/front-matter">官方文档</a>。</p><p>也就是说，我们在 Obsidian 中每创建一篇新文章，都需要在最开头附上一段这样的信息。为了节省操作，我推荐使用模版插件来自动生成这样的内容。</p><p>在 Obsidian 设置界面里的 Community Plugins 中搜索 “Templater”，并安装该插件。然后在项目目录下创建一个名为 <code>templater</code> 的空文件夹，并在插件设置中指定该路径为模版文件夹。在 <code>templater</code> 中创建一个新文件（随便起名字），填入以下内容并按需修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;&lt;% tp.file.title %&gt;&#x27;</span><br><span class="hljs-attr">date:</span> &lt;%<span class="language-ruby"> tp.date.now(<span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) </span>%&gt;<br><span class="hljs-attr">updated:</span> &lt;%<span class="language-ruby"> tp.date.now(<span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) </span>%&gt;<br><span class="hljs-attr">categories:</span>  <br><span class="hljs-attr">tags:</span>  <br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>之后，你在任何新笔记中按下 <code>Alt+E</code> 快捷键，就可以得到所需的 front-matter。类似下面这样<br><img src="/attachments/20240112145528.png"></p><p>Obsidian 也是非常给力，这样的 UI 极大增强了可读性，并方便我们编辑相应内容。</p><h3 id="无缝备份-同步"><a href="#无缝备份-同步" class="headerlink" title="无缝备份 &amp; 同步"></a>无缝备份 &amp; 同步</h3><p>我希望我能在任何设备上都能编辑并发布文章，这就需要让这整个项目跨设备同步，这样不管我修改 Hexo 设置，还是添加新文章内容，都没有任何阻碍。下面我介绍我的方案，完全免费。</p><p>在文章的最开始，我们其实就 clone 了一个 Git 仓。这个 Git 仓既追踪 Hexo 项目文件，也追踪了所有 Markdown 源文件。那么我们完全可以借助 Git 来管理目录下一切所需的东西。</p><p>首先，前往 Gitee 创建一个私有仓库，名字无所谓。这个仓库负责托管我们整个项目。</p><p>在项目目录下使用以下命令添加我们刚刚远程仓库（必须是 Obsidian Vault 的根目录，否则自动同步插件不能工作）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://gitee.com/me/repo_name.git<br></code></pre></td></tr></table></figure><p>先手动确认一下 push 没有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;message&quot;</span><br>git push --set-upstream origin master<br></code></pre></td></tr></table></figure><p>以上过程如果要求你在命令行输密码，就不是很方便，我推荐使用 ssh key 或 Git Credential Manager 等方案，这样之后使用插件自动同步就省心了。</p><div class="note note-info">            <p>Tips<br>可以使用 <code>git config commit.gpgsign false</code> 来取消 commit 签名，反正这个项目只在私有仓里备份，并不对其他人可见。</p>          </div><p>确认 Git 可以进行 push&#x2F;pull 操作后，我们使用插件来把同步全自动化。前往 Obsidian 搜索插件 “Obsidian-git” 并安装。</p><ul><li>如果你希望手动同步，那么用快捷键唤起 command palette 后输入 “git” 就可以快速执行各种 git 操作。其中，”Obsidian Git: Create Backup” 命令会保存所有修改、创建 commit、push 到远程仓库，非常实用。</li><li>如果希望自动同步，可以在插件设置中开启 “Auto backup after stopping file edits” 并设置你喜欢的 “Vault backup interval”。</li><li>此外，”Pull updates on startup”, “Push on backup”, 和 “Pull changes before push” 都是很实用的，推荐开启。</li></ul><p>至此，我们先前配置 Hexo 项目、Obsidian Vault 都可以进行自动备份和跨设备同步了。到了新的设备上，我们只需要准备好 nodejs, git, 以及 Obsidian，就不需要再进行配置了，非常方便。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我使用了三个非常 amazing 的工具来帮我自动化发布网站：</p><ul><li>Hexo 可以把一个目录下的所有 Markdown 文件转化为网站文章</li><li>GitHub Pages 可以免费部署静态网站</li><li>Obsidian 提供了完美的撰写体验</li></ul><p>创建新文章并发布的工作流如下：</p><ol><li>打开 Obsidian，在 <code>source/_posts</code> 下创建新笔记</li><li>填写文章标题</li><li>按下快捷键，插入 front-matter 模版，然后按需编辑</li><li>撰写内容，使用 Markdown 书写</li><li>打开命令行，输入 <code>hexo s</code> 预览效果</li><li>打开命令行，输入 <code>hexo deploy -g</code> 发布</li><li>稍等片刻，即可在 <code>https://&lt;username&gt;.github.io</code> 看到新文章~</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试样式</title>
    <link href="/2024/01/11/Test/"/>
    <url>/2024/01/11/Test/</url>
    
    <content type="html"><![CDATA[<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>Here is a PyTorch implementation of Supervised Contrastive Loss, which is proposed by Khosla et al.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Supervised Contrastive Learning. [https://arxiv.org/abs/2004.11362](https://arxiv.org/abs/2004.11362)">[1]</span></a></sup>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Yonglong Tian (yonglong@mit.edu)</span><br><span class="hljs-string">Date: May 07, 2020</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SupConLoss</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Supervised Contrastive Learning: https://arxiv.org/pdf/2004.11362.pdf.</span><br><span class="hljs-string">    It also supports the unsupervised contrastive loss in SimCLR&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, temperature=<span class="hljs-number">0.07</span>, contrast_mode=<span class="hljs-string">&#x27;all&#x27;</span>,</span><br><span class="hljs-params">                 base_temperature=<span class="hljs-number">0.07</span></span>):<br>        <span class="hljs-built_in">super</span>(SupConLoss, self).__init__()<br>        self.temperature = temperature<br>        self.contrast_mode = contrast_mode<br>        self.base_temperature = base_temperature<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, features, labels=<span class="hljs-literal">None</span>, mask=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute loss for model. If both `labels` and `mask` are None,</span><br><span class="hljs-string">        it degenerates to SimCLR unsupervised loss:</span><br><span class="hljs-string">        https://arxiv.org/pdf/2002.05709.pdf</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            features: hidden vector of shape [bsz, n_views, ...].</span><br><span class="hljs-string">            labels: ground truth of shape [bsz].</span><br><span class="hljs-string">            mask: contrastive mask of shape [bsz, bsz], mask_&#123;i,j&#125;=1 if sample j</span><br><span class="hljs-string">                has the same class as sample i. Can be asymmetric.</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            A loss scalar.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        device = (torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>                  <span class="hljs-keyword">if</span> features.is_cuda<br>                  <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>))<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;`features` needs to be [bsz, n_views, ...],&#x27;</span><br>                             <span class="hljs-string">&#x27;at least 3 dimensions are required&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &gt; <span class="hljs-number">3</span>:<br>            features = features.view(features.shape[<span class="hljs-number">0</span>], features.shape[<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>)<br><br>        batch_size = features.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Cannot define both `labels` and `mask`&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            mask = torch.eye(batch_size, dtype=torch.float32).to(device)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            labels = labels.contiguous().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> labels.shape[<span class="hljs-number">0</span>] != batch_size:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Num of labels does not match num of features&#x27;</span>)<br>            mask = torch.eq(labels, labels.T).<span class="hljs-built_in">float</span>().to(device)<br>        <span class="hljs-keyword">else</span>:<br>            mask = mask.<span class="hljs-built_in">float</span>().to(device)<br><br>        contrast_count = features.shape[<span class="hljs-number">1</span>]<br>        contrast_feature = torch.cat(torch.unbind(features, dim=<span class="hljs-number">1</span>), dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> self.contrast_mode == <span class="hljs-string">&#x27;one&#x27;</span>:<br>            anchor_feature = features[:, <span class="hljs-number">0</span>]<br>            anchor_count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.contrast_mode == <span class="hljs-string">&#x27;all&#x27;</span>:<br>            anchor_feature = contrast_feature<br>            anchor_count = contrast_count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Unknown mode: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.contrast_mode))<br><br>        <span class="hljs-comment"># compute logits</span><br>        anchor_dot_contrast = torch.div(<br>            torch.matmul(anchor_feature, contrast_feature.T),<br>            self.temperature)<br>        <span class="hljs-comment"># for numerical stability</span><br>        logits_max, _ = torch.<span class="hljs-built_in">max</span>(anchor_dot_contrast, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>        logits = anchor_dot_contrast - logits_max.detach()<br><br>        <span class="hljs-comment"># tile mask</span><br>        mask = mask.repeat(anchor_count, contrast_count)<br>        <span class="hljs-comment"># mask-out self-contrast cases</span><br>        logits_mask = torch.scatter(<br>            torch.ones_like(mask),<br>            <span class="hljs-number">1</span>,<br>            torch.arange(batch_size * anchor_count).view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).to(device),<br>            <span class="hljs-number">0</span><br>        )<br>        mask = mask * logits_mask<br><br>        <span class="hljs-comment"># compute log_prob</span><br>        exp_logits = torch.exp(logits) * logits_mask<br>        log_prob = logits - torch.log(exp_logits.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>))<br><br>        <span class="hljs-comment"># compute mean of log-likelihood over positive</span><br>        <span class="hljs-comment"># modified to handle edge cases when there is no positive pair</span><br>        <span class="hljs-comment"># for an anchor point. </span><br>        <span class="hljs-comment"># Edge case e.g.:- </span><br>        <span class="hljs-comment"># features of shape: [4,1,...]</span><br>        <span class="hljs-comment"># labels:            [0,1,1,2]</span><br>        <span class="hljs-comment"># loss before mean:  [nan, ..., ..., nan] </span><br>        mask_pos_pairs = mask.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br>        mask_pos_pairs = torch.where(mask_pos_pairs &lt; <span class="hljs-number">1e-6</span>, <span class="hljs-number">1</span>, mask_pos_pairs)<br>        mean_log_prob_pos = (mask * log_prob).<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>) / mask_pos_pairs<br><br>        <span class="hljs-comment"># loss</span><br>        loss = - (self.temperature / self.base_temperature) * mean_log_prob_pos<br>        loss = loss.view(anchor_count, batch_size).mean()<br><br>        <span class="hljs-keyword">return</span> loss<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Supervised Contrastive Learning. <a href="https://arxiv.org/abs/2004.11362">https://arxiv.org/abs/2004.11362</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
