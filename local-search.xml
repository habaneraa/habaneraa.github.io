<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CVE to CWE Root Cause Mapping Guidance (双语对照)</title>
    <link href="/2024/07/02/cve-to-cwe-root-cause-mapping-guidance/"/>
    <url>/2024/07/02/cve-to-cwe-root-cause-mapping-guidance/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-to-CWE-Root-Cause-Mapping-Guidance-漏洞到弱点的根本原因映射指南"><a href="#CVE-to-CWE-Root-Cause-Mapping-Guidance-漏洞到弱点的根本原因映射指南" class="headerlink" title="CVE to CWE Root Cause Mapping Guidance 漏洞到弱点的根本原因映射指南"></a>CVE to CWE Root Cause Mapping Guidance 漏洞到弱点的根本原因映射指南</h1><p>Original page: <a href="https://cwe.mitre.org/documents/cwe_usage/guidance.html">https://cwe.mitre.org/documents/cwe_usage/guidance.html</a></p><p><strong>Document Version:</strong>  1.1 <em>(Released 3&#x2F;22&#x2F;2024)</em></p><p>This guidance is intended to help <a href="https://www.cve.org/PartnerInformation/Partner#CNA">CVE Numbering Authorities (CNAs)</a> and those who produce or analyze <a href="https://www.cve.org/About/Process#CVERecordLifecycle">CVE Records</a> to better identify and disclose the root causes of vulnerabilities . It is also likely to be helpful to those who are analyzing vulnerabilities that are not tracked by the CVE Program.</p><p>文档版本：1.1 (于 2024 年 3 月 22 日 发布)</p><p>本指南旨在帮助 CVE 编号授权机构 (CNA) 和那些制作或分析 CVE 记录的人员更好地识别和披露漏洞的根本原因。对于分析不在 CVE 计划追踪范围内的漏洞的人员来说，本指南也可能有所帮助。</p><h2 id="What-is-Root-Cause-Mapping"><a href="#What-is-Root-Cause-Mapping" class="headerlink" title="What is Root Cause Mapping?"></a>What is Root Cause Mapping?</h2><p>Root cause mapping is the identification of the underlying cause(s) of a vulnerability. This is best done by correlating CVE Records and&#x2F;or bug or vulnerability tickets with CWE entries. Today, this is not done accurately at scale by the vulnerability management ecosystem.</p><p>根本原因映射是指识别漏洞的潜在原因。即将 CVE 记录与 CWE 条目关联起来。目前，漏洞管理生态系统尚未在大规模上准确地完成这项工作。</p><p>Accurate root cause mapping is valuable because it directly illuminates where investments, policy, and practices can address the root causes responsible for vulnerabilities so that they can be eliminated. This applies to both industry and government decision makers. Additionally, it enables:</p><ol><li>Driving the removal of classes of vulnerabilities: Root cause mapping encourages a valuable feedback loop into a vendor’s SDLC or architecture design planning</li><li>Saving money: the more weaknesses avoided in your product development, the less vulnerabilities to manage after deployment</li><li>Trend analysis (e.g., how big of a problem is memory safety compared to other problems like injection)</li><li>Further insight to potential “exploitability” based on root cause (e.g., command injection vulnerabilities tend to see increased adversary attention, be targeted by certain actors)</li><li>Organizations demonstrating transparency to customers how they are targeting and tackling problems in their products</li></ol><p>准确的根本原因映射很有价值，因为它直接揭示了在哪些方面进行投资、制定政策和实践可以解决导致漏洞的根本原因，从而消除这些漏洞。这适用于行业政府决策者和政府决策者。此外，它还能实现：</p><ol><li>推动消除某些类别的漏洞:根本原因映射鼓励将有价值的反馈纳入供应商的软件开发生命周期或架构设计规划中</li><li>节省资金:在产品开发中避免的弱点越多，部署后需要管理的漏洞就越少</li><li>趋势分析(例如，与其他问题相比，内存安全问题有多严重)</li><li>根据根本原因进一步洞察潜在的”可利用性”(例如，命令注入漏洞往往会引起更多攻击者的关注，被某些行为者针对)</li><li>组织向客户展示他们如何针对和解决产品中的问题</li></ol><h2 id="Overview-–-What-is-CWE"><a href="#Overview-–-What-is-CWE" class="headerlink" title="Overview – What is CWE?"></a>Overview – What is CWE?</h2><p>Common Weakness Enumeration (CWE™) is a community-developed list of common software and hardware weaknesses. A “weakness” is a condition in a software, firmware, hardware, or service component that, under certain circumstances, could contribute to the introduction of vulnerabilities. Referred to as CWEs, weaknesses are named, defined, and given a unique identifier on the CWE website. Weaknesses can occur in the design, implementation, or other phases of a product lifecycle. Many vulnerabilities have the same CWE as their root cause, independent of vendor, coding language, etc.</p><p>通用弱点列举 (CWE™) 是一个由社区开发的常见软件和硬件弱点列表。”弱点”是指软件、固件、硬件或服务组件中的一种状况，在某些情况下可能会导致漏洞的产生。这些被称为 CWE 的弱点在 CWE 网站上被命名、定义并给予唯一标识符。弱点可能出现在产品生命周期的设计、实施或其他阶段。许多漏洞具有相同的 CWE 作为其根本原因，这与供应商、编码语言等无关。</p><h3 id="Weakness-vs-Vulnerability-Language"><a href="#Weakness-vs-Vulnerability-Language" class="headerlink" title="Weakness vs. Vulnerability Language"></a>Weakness vs. Vulnerability Language</h3><p>As defined by the CVE Program, a vulnerability is an instance of one or more weaknesses in a Product that can be exploited, causing a negative impact to confidentiality, integrity, or availability; a set of conditions or behaviors that allows the violation of an explicit or implicit security policy.</p><p>CVE Record descriptions describe a vulnerability that has occurred in a product, often focusing on the technical impacts of its exploitation or exploitation prerequisites. Examples of technical impact phrases include “bypass authorization”, “gain privileges”, or “execute malicious code”. They describe the result of the vulnerability and its attack vectors, not the root cause(s).</p><p>根据 CVE 计划的定义，漏洞是指产品中存在的一个或多个弱点，这些弱点可能被利用，从而对机密性、完整性或可用性造成不利影响；它们是一组违反了明确或隐含安全策略的条件或行为。CVE 记录详细描述了产品中出现的漏洞，通常着重于其技术影响或利用条件。例如，技术影响可能包括 “绕过授权”、“提升权限” 或 “执行恶意代码”，这些描述了漏洞的后果及其攻击方式，而非根本原因。</p><p>Examples of exploitation prerequisite phrases include “unauthorized user”, “unauthenticated remote attacker”, or “admin user”. While these phrases could be interpreted as being related to access control CWEs, they are not describing a weakness.</p><p>利用条件可能包括 “未授权用户”、“未经验证的远程攻击者” 或 “管理员用户”。尽管这些描述可能与访问控制相关，但它们并不直接说明弱点本身。</p><p>In contrast, accurately mapping a CVE Record to a CWE requires information describing an issue that led to the vulnerability. Examples of weakness language include “missing authentication”, “improper bounds check”, or “stack-based buffer overflow”.</p><p>相比之下，将 CVE 记录准确映射到 CWE 需要详细描述导致漏洞的问题。例如，弱点可能包括 “缺乏身份验证”、“不当的边界检查” 或 “基于栈的缓冲区溢出”。</p><blockquote><p><strong>Insecure Direct Object Reference</strong> (weakness) in MyProduct 10.1 to 10.6 allows an <strong>unauthenticated attacker</strong> (prerequisite) to <strong>read sensitive data and execute specific commands and functions with full admin rights</strong> (technical impact) via the page parameter to the &#x2F;api&#x2F;xyz API endpoint.</p></blockquote><h2 id="CWE-Resources-CWE-Entry-Structure"><a href="#CWE-Resources-CWE-Entry-Structure" class="headerlink" title="CWE Resources &amp; CWE Entry Structure"></a>CWE Resources &amp; CWE Entry Structure</h2><p>It is helpful to be familiar with how CWE defines weaknesses before diving into different ways of mapping. Having a clear grasp on these crucial components will help the overall mapping experience.</p><p>在深入了解不同的映射方法之前，了解 CWE 如何定义弱点是很有帮助的。清楚地掌握这些关键组成部分很有用。</p><h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><p>To provide a common language, CWE has a <a href="https://cwe.mitre.org/documents/glossary/index.html">glossary of terminology</a> derived from <a href="https://cwe.mitre.org/documents/vulnerability_theory/intro.html">vulnerability theory</a>.</p><p>Terms can often mean different things based on the situation and the context in which they are used, as well as individuals’ skills and experience in vulnerability management, or other related things that introduce subjectivity. Becoming familiar with these terms can help streamline utility of the CWE corpus.</p><p><strong>Common and Widely Used Terms in CWE</strong></p><p>The following highlights some of the most common terms in CWE, which are chosen based on their prevalence within CWE, vulnerability theory, and industry. They are presented here to alleviate confusion surrounding their meanings. This will lead to the selection of accurate, precise CWE(s) for root cause mapping.</p><ul><li>Important characteristics of weaknesses: <a href="https://cwe.mitre.org/documents/glossary/index.html#Behavior">Behavior</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Property">Property</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Technology">Technology</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Resource">Resource</a></li><li>Behavior qualifiers: <a href="https://cwe.mitre.org/documents/glossary/index.html#Improper">Improper</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Incorrect">Incorrect</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Missing">Missing</a></li><li>Protection mechanisms: <a href="https://cwe.mitre.org/documents/glossary/index.html#Authentication">Authentication</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Authorization">Authorization</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Neutralization">Neutralization</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Permissions">Permissions</a></li></ul><h3 id="CWE-Relationships"><a href="#CWE-Relationships" class="headerlink" title="CWE Relationships"></a>CWE Relationships</h3><p>CWE contains over 900 weaknesses which range from abstract and conceptual to precise and technology specific. A precise weakness will have a “parent” weakness that is more abstract, which may also have “parent” weaknesses, and so on.</p><p>CWE 包含超过 900 个弱点，包含抽象的概念性弱点、具体的技术性弱点。一个具体的弱点会有更抽象的”父”弱点，而这个”父”弱点可能也有”父”弱点，依此类推。</p><p>There are four types of weakness abstractions: <a href="https://cwe.mitre.org/documents/glossary/index.html#Pillar%20Weakness">Pillar</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Class%20Weakness">Class</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Base%20Weakness">Base</a>, and <a href="https://cwe.mitre.org/documents/glossary/index.html#Variant%20Weakness">Variant</a>. These abstraction types correlate with the amount of specific information in the CWE. This specific information includes dimensions such as <a href="https://cwe.mitre.org/documents/glossary/index.html#Behavior">behavior</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Property">property</a>, <a href="https://cwe.mitre.org/documents/glossary/index.html#Resource">resource</a>, coding language, and <a href="https://cwe.mitre.org/documents/glossary/index.html#Technology">technology</a>. A set of weaknesses can be grouped into a Category, which is simply a collection of similar weaknesses that share common characteristics, but not the same combination of the dimensions above.</p><p>一共有四种弱点抽象等级：支柱、类、基础和变体。这些抽象类型与 CWE 中特定信息的数量相关。这些特定信息包括行为、属性、资源、编码语言和技术等维度。一组弱点可以被归类为一个类别，这只是一个具有共同特征的类似弱点的集合，但不具有上述维度的相同组合。</p><p><img src="/attachments/weakness_abstractions.png"></p><p>For root cause mapping, CWEs at the <a href="https://cwe.mitre.org/documents/glossary/index.html#Base">Base</a> and <a href="https://cwe.mitre.org/documents/glossary/index.html#Variant">Variant</a> level should be used whenever possible to ensure providing adequate specificity, actionability, and root cause information for a vulnerability. <a href="https://cwe.mitre.org/documents/glossary/index.html#Class">Class</a> level CWEs may be used for root cause mapping if there is no accurate <a href="https://cwe.mitre.org/documents/glossary/index.html#Base">Base</a> or <a href="https://cwe.mitre.org/documents/glossary/index.html#Variant">Variant</a> level CWE.</p><p>对于根本原因映射，应尽可能使用基础和变体级别的 CWE，以确保为漏洞提供足够的特异性、可操作性和根本原因信息。如果没有准确的基础或变体级别的 CWE，可以使用类级别的 CWE 进行根本原因映射。</p><p>Every CWE contains a Vulnerability Mapping label under its title, as well as Mapping Notes to assist with root cause mapping efforts. The possible labels are provided below:</p><ul><li>ALLOWED: this CWE ID could be used to map to real-world vulnerabilities</li><li>ALLOWED: with careful review of mapping notes</li><li>DISCOURAGED: this CWE ID should not be used to map to real-world vulnerabilities</li><li>PROHIBITED: this CWE ID must not be used to map to real-world vulnerabilities</li></ul><p>每个 CWE 在其标题下都包含一个漏洞映射标签，以及帮助进行根本原因映射的映射说明。可能的标签如下：</p><ul><li>允许：此 CWE ID 可用于映射到现实世界的漏洞</li><li>允许:仔细查看映射说明</li><li>不鼓励：此 CWE ID 不应用于映射到现实世界的漏洞</li><li>禁止：此 CWE ID 不得用于映射到现实世界的漏洞</li></ul><p><img src="/attachments/cwe_actionable.png"></p><p>These labels are intended to ensure that root cause mapping provides appropriately precise and actionable correlations between CWE and CVE Records. CWE Mapping Notes – which are linked to under each CWE’s title – provide additional details and helpful considerations with respect to using the CWE for root cause mapping.</p><p>这些标签旨在确保根本原因映射在 CWE 和 CVE 记录之间提供适当精确和可操作的相关性。CWE 映射说明（附在每个 CWE 条目下）提供了关于使用 CWE 的额外细节。</p><h2 id="Mapping-Methodologies"><a href="#Mapping-Methodologies" class="headerlink" title="Mapping Methodologies"></a>Mapping Methodologies</h2><p>There are different ways to identify accurate weakness mapping(s) for a CVE Record. While one may be easier for some users versus another, a best practice is to verify your intended mapping with a colleague with slightly different skills and experience than you. Before starting, be sure to review the <a href="https://cwe.mitre.org/documents/cwe_usage/mapping_examples.html">example root cause mappings</a>. Understanding the process and reasoning behind each example will help when using any of the following methods.</p><p>有不同的方法来识别 CVE 记录的准确弱点映射。虽然某些用户可能觉得某种方法更容易，但最佳实践是与技能和经验略有不同的同事验证你的预期映射。在开始之前，请务必查看示例根本原因映射。了解每个示例背后的过程和推理将有助于使用以下任何方法。</p><h3 id="Keyword-Search-Method"><a href="#Keyword-Search-Method" class="headerlink" title="Keyword Search Method"></a>Keyword Search Method</h3><p>CWE has a search feature available on the home page of the CWE website, illustrated below.</p><p>You can search for keywords, or known CWE-IDs, or even a general term in the search box. This will find all matching pages to that term on the CWE web site, as all web pages are indexed.</p><p>CWE 在其网站主页上提供了搜索功能。你可以在搜索框中搜索关键词、已知的 CWE-ID，甚至是一般术语。</p><blockquote><p>✔ To limit your search to only individual CWE entry pages, include “inurl:definitions” in your query<br>要将搜索限制为仅包含单个 CWE 条目页面，请在查询中包含 “inurl:definitions”</p></blockquote><h3 id="The-CWE-View-Methods"><a href="#The-CWE-View-Methods" class="headerlink" title="The CWE View Methods"></a>The CWE View Methods</h3><p>A CWE “<a href="https://cwe.mitre.org/documents/glossary/index.html#View">View</a>” is a collection of weaknesses organized for a specific purpose or targeted at a specific audience. Most Views are a subset of the overall CWE list, but some Views include all CWE weaknesses. Using a View allows easier navigation of the CWE list according to a specific point of view. Note that a View is not a weakness itself but is a specific grouping of the CWE list. Depending on the View and its purpose, it may contain a flat list of CWE weaknesses, or it could contain a hierarchical view of CWE weaknesses broken into Categories.</p><p>CWE “视图”是为特定目的或针对特定受众组织的弱点集合。大多数视图是整个 CWE 列表的子集，但有些视图包括所有 CWE 弱点。使用视图可以根据特定观点更轻松地浏览 CWE 列表。请注意，视图本身不是弱点，而是 CWE 列表的特定分组。根据视图及其目的，它可能包含 CWE 弱点的平面列表，或者可能包含分为类别的 CWE 弱点的层次视图。</p><p><strong>Developer View <a href="https://cwe.mitre.org/data/definitions/699.html">(View-699)</a></strong></p><p>This View organizes a subset of ~400 CWEs around concepts that are frequently used or encountered in software development. By design, this view is only 2 levels deep. The top level has categories of developer-friendly concepts to facilitate easier navigation (remember: never map a vulnerability to a CWE Category). The second level contains Base level weaknesses.</p><p>此视图围绕软件开发中经常使用或遇到的概念组织了约 400 个 CWE 的子集。该视图设计为仅有 2 个层级。顶层包含开发者友好的概念类别，以便于导航(记住:永远不要将漏洞映射到 CWE 类别)。第二层包含基础级别的弱点。</p><p><strong>Software Assurance Trends View <a href="https://cwe.mitre.org/data/definitions/1400.html">(View-1400)</a></strong></p><p>This view contains every CWE. CWEs are organized into 22 high-level categories of interest to large-scale software assurance research to support the elimination of weaknesses using tactics such as secure language development. This view is structured with categories at the top level, with a second level of only weaknesses.</p><p>此视图包含每个 CWE。CWE 被组织成 22 个高级类别，这些类别与大规模软件保障研究相关，旨在支持使用安全语言开发等策略消除弱点。该视图的结构为顶层类别，第二层仅包含弱点。</p><p><strong>Research View <a href="https://cwe.mitre.org/data/definitions/1000.html">(View-1000)</a></strong></p><p>This View also contains every CWE. It has a deep tree structure, beginning with 10 high-level Pillars. It might be especially useful when you are looking for unusual weaknesses, as you could perform a top-down search.</p><p>此视图也包含每个 CWE。它具有深层树状结构，从 10 个高级支柱开始。当你在寻找不常见的弱点时，这可能特别有用，因为你可以进行自上而下的搜索。</p><p><strong>Hardware Design View <a href="https://cwe.mitre.org/data/definitions/1194.html">(View-1194)</a></strong></p><p>This View organizes ~100 weaknesses around concepts that are frequently used or encountered in hardware design. Similar to View-699, this View also tries to be only 2 levels deep. The top level has categories of designer&#x2F;architect-friendly concepts to facilitate navigation (remember: never map a vulnerability to a CWE Category). The second level contains Base&#x2F;Class level weaknesses.</p><p>此视图围绕硬件设计中经常使用或遇到的概念组织了约 100 个弱点。与视图-699 类似，该视图也尝试仅保持 2 个层级。顶层包含设计师&#x2F;架构师友好的概念类别，以便于导航(记住:永远不要将漏洞映射到 CWE 类别)。第二层包含基础&#x2F;类级别的弱点。</p><p><strong>NVD View <a href="https://cwe.mitre.org/data/definitions/1003.html">(View-1003)</a></strong></p><p>This View organizes a subset of ~130 CWEs most commonly seen in the National Vulnerability Database (NVD).</p><p>此视图组织了在 NVD 中最常见的约 130 个 CWE 子集。</p><h3 id="If-a-Mapping-Still-Cannot-be-Found"><a href="#If-a-Mapping-Still-Cannot-be-Found" class="headerlink" title="If a Mapping Still Cannot be Found"></a>If a Mapping Still Cannot be Found</h3><p>If you’ve exhausted your search and still can’t find an appropriate weakness to map your vulnerability, you may have found a gap in CWE coverage! Although CWE tries to be comprehensive, we recognize that we’re likely to miss certain areas from time to time. Please see the <a href="https://cwe.mitre.org/community/submissions/overview.html">CWE Submission Information</a> and we’ll work with you to create a CWE on that topic.</p><h2 id="Common-Terms-Cheatsheet"><a href="#Common-Terms-Cheatsheet" class="headerlink" title="Common Terms Cheatsheet"></a>Common Terms Cheatsheet</h2><p><strong>Pillar Weakness</strong>: These are the highest-level weaknesses that cannot be made any more abstract. They typically only describe one or two dimensions at a high level of abstraction.</p><p><strong>支柱弱点</strong>： 这些是最高级别的弱点，无法进一步抽象。它们通常只在高度抽象的层面上描述一个或两个维度。</p><p><strong>Class Weakness</strong>: These are weaknesses that can be described abstractly, typically independent of any specific language or technology. They typically describe two dimensions.</p><p><strong>类弱点</strong>： 这些是可以抽象描述的弱点，通常独立于任何特定语言或技术。它们通常描述两个维度。</p><p><strong>Base Weakness</strong>: These weaknesses build on a Class weakness by providing lower-abstraction concepts for two to three dimensions, although these concepts are still typically associated with groups of specific languages, technologies, or resources.</p><p><strong>基础弱点</strong>： 这些弱点建立在类弱点的基础上，为两到三个维度提供较低抽象概念，尽管这些概念通常仍与特定语言、技术或资源组相关联。</p><p><strong>Variant Weakness</strong>: These weaknesses build on a Base weakness by linking to an individual type of language, technology, or resource. They typically cover three or more dimensions.</p><p><strong>变体弱点</strong>： 这些弱点建立在基础弱点之上，链接到单个类型的语言、技术或资源。它们通常涵盖三个或更多维度。</p><p><strong>Resource</strong>: A vulnerability theory term for an object or entity that is accessed or modified within the operation of the product, such as memory, CPU, files, or sockets. Resources can be system-level (memory or CPU), code-level (function or variable), or application-level (cookie or message).</p><p><strong>资源</strong>： 漏洞理论术语，指在产品操作中访问或修改的对象或实体，如内存、CPU、文件或套接字。资源可以是系统级(内存或 CPU)、代码级(函数或变量)或应用级(cookie 或消息)。</p><p><strong>Information Exposure</strong>: The intentional or unintentional disclosure of information to an actor that is not explicitly authorized to have access to that information.</p><p><strong>信息泄露</strong>： 有意或无意地向未明确授权访问该信息的行为者披露信息。</p><p><strong>Improper</strong>: Used as a catch-all term to cover security behaviors that are either “Missing” or “Incorrect”.</p><p><strong>不当</strong>： 用作涵盖”缺失”或”不正确”的安全行为的总称。</p><p><strong>Missing</strong>: Used to describe a behavior that the developer has not attempted to perform.</p><p><strong>缺失</strong>： 用于描述开发人员尚未尝试执行的行为。</p><p><strong>Incorrect</strong>: A general term, used to describe when a behavior attempts to do a task but does not do it correctly.</p><p><strong>不正确</strong>： 一个通用术语，用于描述当行为试图执行任务但未正确执行时的情况。</p><p><strong>Authentication</strong>: The process of verifying that an actor has a specific real-world identity, typically by checking for information that the product assumes can only be produced by that actor.</p><p><strong>身份验证</strong>： 验证行为者具有特定现实世界身份的过程，通常通过检查产品假定只能由该行为者产生的信息来完成。</p><p><strong>Authorization</strong>: The process of determining whether an actor with a given identity is allowed to have access to a resource, then granting access to that resource, as defined by the implicit and explicit security policies for the system.</p><p><strong>授权</strong>： 确定具有给定身份的行为者是否被允许访问资源，然后根据系统的隐式和显式安全策略授予对该资源的访问权限的过程。</p><p><strong>Permissions</strong>: The explicit specifications for a resource, or a set of resources, that defines which actors are allowed to access that resource, and which actions may be performed by those actors.</p><p><strong>权限</strong>： 对资源或一组资源的明确规定，定义了哪些行为者被允许访问该资源，以及这些行为者可以执行哪些操作。</p><p><strong>Neutralization</strong>: A general term to describe the process of ensuring that input or output has certain security properties before it is used. This is independent of the specific protection mechanism that performs the neutralization. The term could refer to one or more of the following: filtering&#x2F;cleansing, canonicalization&#x2F;resolution, encoding&#x2F;decoding, escaping&#x2F;unescaping, quoting&#x2F;unquoting, validation, or other mechanisms.</p><p><strong>中和</strong>： 一个通用术语，用于描述确保输入或输出在使用前具有某些安全属性的过程。这与执行中和的具体保护机制无关。该术语可能指以下一项或多项：过滤&#x2F;清理、规范化&#x2F;解析、编码&#x2F;解码、转义&#x2F;反转义、引用&#x2F;取消引用、验证或其他机制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无痛 Python 环境（Linux 机器）</title>
    <link href="/2024/05/29/painless-python-env/"/>
    <url>/2024/05/29/painless-python-env/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 是一门灵活、多用途的编程语言，几乎在所有场合都有用武之地。经过多年的发展，Python 语言拥有数量庞大的工具链，其“配环境”的过程经常让初学者感到头疼。本文从开发工具的基本概念入手，希望帮助大家无痛解决 Python 配环境问题。</p><p>在进行实操前，我们快速扫一下几个常见概念：</p><ul><li>Python 解释器：负责解析源代码并执行相应功能的程序，一台机器上可能同时拥有多个解释器，它们可能对应不同的版本和依赖库</li><li>Python 版本：Python 编程语言本身的版本。一般来说，Python3 的新版本可以兼容所有 Python3 老版本代码，而较老的解释器可能无法执行某些新特性。如果没有特殊需求，建议使用最新的 Python 3.12，尽量不要使用过老版本，甚至是 Python2</li><li>Python 包和虚拟环境：要想在代码中使用第三方包，就需要在当前环境中安装包。第三方包之间会有复杂的版本依赖。为了在不同项目中隔离依赖，虚拟环境允许你创建一个完全独立的 Python 解释器，这是非常有用的。</li></ul><p>你可能听说过很多和虚拟环境相关的 Python 开发工具，比如 pip, conda, pipenv, poetry 等，它们可能会提供以下功能：</p><ul><li>Python 版本管理：允许你安装多个 Python 版本并切换</li><li>Python 包管理：负责下载、安装、卸载第三方包，并妥善处理它们之间的依赖关系</li><li>虚拟环境管理：创建相互独立的虚拟环境</li><li>项目打包：构建、发布你开发的 Python 包</li></ul><p><img src="/attachments/py-tools-category.png"></p><p>上图来自 <a href="https://alpopkes.com/posts/python/packaging_tools/#categorization">这篇博客</a> ，它展示了许多工具的功能范畴。例如常见的 conda 实际上同时提供了版本管理、包管理、虚拟环境管理等功能。</p><p>哪个工具最好？我该如何选择？—— 没有最好的工具，只有符合需求的工具才是最好的。Python 语言有非常多的用途，每种用途都可能有不一样的需要：</p><ul><li><strong>数据分析&#x2F;可视化</strong> 通常需要 notebook 环境，并且依赖的第三方包相对固定</li><li><strong>深度学习研究</strong> 可能会涉及许多不成熟的第三方依赖，使用虚拟环境较为频繁</li><li><strong>工作自动化</strong> 编写脚本、一次性执行，不过分强调依赖隔离，只需要一定数量的第三方包</li><li><strong>Web 开发</strong> 通常需要较为严格的依赖管理和项目打包</li></ul><p>本文推荐使用 conda 和 poetry 这两个主流工具。以 Linux 机器为例进行演示，默认读者有基本的 Linux 知识。</p><h3 id="安装-conda"><a href="#安装-conda" class="headerlink" title="安装 conda"></a>安装 conda</h3><p>conda 的优势：</p><ul><li>能够支持 Python 语言以外的依赖，相比于 Python 专用的 pip 更强大</li><li>能很好地和 pip 同时使用</li><li>同时提供 Python 版本管理和虚拟环境管理</li></ul><p>conda 的劣势：</p><ul><li>依赖解析可能比较慢，依赖管理相对宽松</li><li>不支持 <code>pyproject.toml</code> 相关功能，不提供打包功能</li></ul><p>除非你希望你的 Python 能开箱即用（Anaconda 极为臃肿），否则一律推荐 miniconda。其安装方法如下：</p><p>第一步，下载 miniconda3 安装文件，此处使用清华镜像站，下载速度更快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh<br></code></pre></td></tr></table></figure><p>第二步，使用 <code>bash miniconda.sh</code> 执行安装程序，请根据命令行指引，逐步安装。我们假设安装路径为 <code>~/miniconda3</code>。安装完成后该文件就没用了，可以直接使用 <code>rm miniconda3</code> 删除。</p><p>第三步，将 conda 绑定到你的 shell，例如我使用 zsh，那么就执行以下命令。该命令的作用是添加一段脚本到 <code>~/.zshrc</code> 文件。然后重启 shell 即可生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/miniconda3/bin/conda init zsh<br></code></pre></td></tr></table></figure><p>如果成功安装，重启 shell 后，你将会在 shell prompt 中看到 “(base)” 的标识，这代表你现在位于 conda 的 base 环境中。然后就可以创建虚拟环境了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n myenv python=3.10<br></code></pre></td></tr></table></figure><p>为了更快地下载包，我们可以使用清华镜像站：</p><ul><li>修改 <code>~/.condarc</code> 文件，参考 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华镜像站指引</a> 添加相应内容</li><li>对于 pip，也可以通过命令来指定 <code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></li></ul><p>其他注意事项：</p><ul><li>conda 本身不依赖系统的 Python，所以你无需安装其他任何 Python 就能直接使用 conda 环境。</li><li>配合 IDE (如 VSCode) 使用时，请注意在左下角选择正确的 Python 解释器。</li><li>安装依赖时，请确认已经使用 <code>conda activate &lt;env&gt;</code> 切换到正确的虚拟环境。</li><li>conda 很容易“重开”，如果环境没配好，直接删了重新创建虚拟环境就可以了。conda 自身的重装也很容易，直接删除整个安装目录即可，没有副作用。</li></ul><h3 id="安装-poetry"><a href="#安装-poetry" class="headerlink" title="安装 poetry"></a>安装 poetry</h3><p>poetry 的优势：</p><ul><li>专注 Python 项目，一个项目对应一个虚拟环境，并提供打包和发布功能，完整支持 <code>pyproject.toml</code></li><li>依赖解析功能强大，一致性好</li></ul><p>poetry 的劣势：</p><ul><li>不能管理 Python 包以外的依赖</li><li>不推荐复用项目环境</li></ul><p>推荐使用 pipx 来安装 poetry。这是因为 poetry 本身是一个基于 Python 语言的命令行工具，而 pipx 能够为每个应用创造独立的运行环境。要使用 pipx，首先需要以 root 身份安装，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install pipx<br></code></pre></td></tr></table></figure><p>然后就可以以用户身份为自己单独安装应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pipx ensurepath<br>pipx install poetry<br></code></pre></td></tr></table></figure><p>同样，poetry 也可以使用 pypi 清华镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry <span class="hljs-built_in">source</span> add --priority=primary mirrors https://pypi.tuna.tsinghua.edu.cn/simple/<br></code></pre></td></tr></table></figure><p>其他注意事项：</p><ul><li>与 conda 的虚拟环境不同的是，poetry 的虚拟环境实际上与 <code>pyproject.toml</code> 绑定。所以在正常情况下，你并不能脱离一个 python 项目创建虚拟环境，并将该环境在多个目录中复用。</li><li>poetry 本身以及 poetry 创建的虚拟环境都依赖外部的 Python。poetry 不提供 Python 版本的管理和切换，如有需要，可以考虑使用 pyenv 等工具。我们之所以推荐使用 pipx 安装 poetry，正是为了防止系统 Python 的依赖影响到 poetry 自身的运行。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>#python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应对 GPU 服务器的过热问题</title>
    <link href="/2024/05/06/gpu-monitoring-management/"/>
    <url>/2024/05/06/gpu-monitoring-management/</url>
    
    <content type="html"><![CDATA[<h2 id="本文背景"><a href="#本文背景" class="headerlink" title="本文背景"></a>本文背景</h2><p>使用老旧的 GPU 机器，散热能力下降，影响性能甚至出现过热现象。现象包括：</p><ol><li>通过 <code>nvidia-smi</code> 命令查看 GPU 温度，发现空载时温度显著高于环境温度（例如 40 度）</li><li>运行比较计算密集的任务时，由于散热较差，GPU 温度压不到合理区间（例如超过 85 度）</li><li>GPU 过热后会触发硬件保护强行切换电源，进程退出且不能再使用 GPU</li></ol><p>过热后可能会出现如下报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Unable to determine the device handle for 0000:02:00.0: Unknown Error<br></code></pre></td></tr></table></figure><p>这里的序号是总线标识符，和 <code>nvidia-smi</code> 命令中查到的 GPU 是对应的，从这里可以得知是哪张 GPU 过热掉电。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>临时解决方式：过热掉电后，等温度降下来后重启机器即可恢复。</p><p>妥协方案：调整 GPU 电源模式。</p><p>首先，在 root 权限下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi -pm 1<br></code></pre></td></tr></table></figure><p>这将开启 GPU 的 “persistence mode”。然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi -pl 100<br></code></pre></td></tr></table></figure><p>这将限制 GPU 的电源功率，从功耗上减少散热，以达到控制温度的目的。这里的 100 代表目标功率，可以随意调整，功率有特定范围，例如 RTX 3090 的功率范围是 100W 到 350W。如果输入了不合法的功率值，会有命令行提示。</p><p>此外，如果多卡机器中不同 GPU 的散热条件不一样，可以通过如下命令单独修改一张卡的功率上限。这在特定卡散热不佳且仍然希望使用多卡训练时很有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi -pl 100 -i 0<br></code></pre></td></tr></table></figure><p>最后，一劳永逸解决方式：花点 w 买新机器。</p><h2 id="GPU-状态及进程监控"><a href="#GPU-状态及进程监控" class="headerlink" title="GPU 状态及进程监控"></a>GPU 状态及进程监控</h2><p>众所周知，<code>nvidia-smi</code> 用于查看 GPU 运行信息，但是它并不美观，而且不能动态更新内容，如果想持续监测 GPU 状态，需要反复执行该命令。因此，我简单列举两个小工具，可以在一定程度上替代 <code>nvidia-smi</code> 。他们均基于 Python，因此推荐使用 pipx 安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install pipx<br>pipx ensurepath<br>pipx install gpustat<br>pipx install nvitop<br></code></pre></td></tr></table></figure><p><a href="https://github.com/wookayin/gpustat">gpustat</a> 是一款轻量命令行工具，定位是 <code>nvidia-smi</code> 的替代品。在命令行直接运行 <code>gpustat</code> 即可输入简洁版的 GPU 状态信息，也可以使用 <code>gpustat --watch</code> 来自动监测。</p><p><a href="https://nvitop.readthedocs.io/en/latest/">nvitop</a> 是另一款命令行工具，提供类似于 htop 的终端 UI，功能比较强大。同样地，在命令行可使用 <code>nvitop</code> 启动它的 UI。它很适合在一段时间范围内监测 GPU 运行状态。</p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>如果希望多卡进程只使用一张或几张卡，可以通过设置环境变量来让进程只使用你指定的 GPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> CUDA_VISIBLE_DEVICES=0,1<br></code></pre></td></tr></table></figure><p>这里的显卡号就是 <code>nvidia-smi</code> 命令最左侧显示的 GPU ID，可用逗号分隔多个。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>光速配置高颜值终端（Windows 机）</title>
    <link href="/2024/04/08/beautiful%20terminal%20on%20windows/"/>
    <url>/2024/04/08/beautiful%20terminal%20on%20windows/</url>
    
    <content type="html"><![CDATA[<p>本文简单记录一下我在新的 Windows 机器上配置高颜值终端的方法。我们可能会在多台 PC 上切换工作，并希望使用的工具保持一致，这其中 “配终端” 就是一个很可能会 “浪费时间” 的过程。我们的主要原则包括：</p><ul><li>使用主流方案和工具，减少问题出现概率</li><li>命令行优先，加快效率</li><li>尽可能美观、可读性佳，同时不要折腾</li></ul><p><img src="/attachments/terminal-demo.png"></p><p>使用到的软件：</p><ul><li>包安装 &amp; 管理: <a href="https://github.com/ScoopInstaller/Scoop">Scoop</a></li><li>终端模拟器 (terminal emulator): <a href="https://github.com/microsoft/terminal">Windows Terminal</a></li><li>终端字体: <a href="https://www.nerdfonts.com/font-downloads">Cascadia Code Nerd Font</a></li><li>Shell prompt: <a href="https://github.com/starship/starship">Starship.rs</a></li></ul><p>接下来我将一一介绍，并在文中附上快速上手的命令。</p><p>注：本文<strong>不涉及 Shell 配置</strong>，这些终端配置可适用于任意 Shell (Powershell, Bash, Zsh, …)。</p><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><p>我为什么使用 Scoop？</p><ul><li>GUI 安装方式<strong>太蠢了</strong>：点浏览器，搜索引擎，找到下载链接，点安装程序，点点点……</li><li>Scoop 是纯命令行操作，而且直观易懂，没有记忆负担</li><li>Scoop 能自动管理各类软件的<strong>安装</strong>、<strong>更新</strong>和<strong>卸载</strong></li><li>Scoop 在家目录下安装所有软件，并且免管理员权限</li><li>不会往 PATH 里塞一大堆东西</li><li>全开源</li></ul><p>Scoop 的缺点：</p><ul><li>对某些闭源 GUI 应用的支持有限，并不万能</li><li>对网络环境要求较高，需要访问 GitHub 才能流畅使用</li></ul><p><strong>快速安装</strong> （使用 Powershell）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> <span class="hljs-literal">-ExecutionPolicy</span> RemoteSigned <span class="hljs-literal">-Scope</span> CurrentUser<br><span class="hljs-built_in">Invoke-RestMethod</span> <span class="hljs-literal">-Uri</span> https://get.scoop.sh | <span class="hljs-built_in">Invoke-Expression</span><br></code></pre></td></tr></table></figure><p>自定义安装请参阅 <a href="https://github.com/ScoopInstaller/Install?tab=readme-ov-file#advanced-installation">该文档</a>.</p><p>推荐使用方式：</p><ol><li>拿到 scoop 第一件事是安装 git: <code>scoop install git</code>，告别 git bash</li><li>添加软件仓库 (buckets)，例如 <code>scoop bucket add extras</code>，该官方仓库收录了许多非命令行软件</li><li>安装下载工具 <code>scoop install aria2</code></li><li>仓库更新和下载问题，裸奔非常容易卡死，开代理一般可以解决</li><li>其他推荐安装：<code>7zip aria2 openssh python</code></li></ol><p>本文以下所有工具都可以使用 <code>scoop install</code> 直接安装。</p><h2 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h2><p>我使用 Windows Terminal。历经五年打磨，微软的新一代终端工具已经在 GitHub 狂揽近十万星。对于 Windows 机器，我真的想不出什么理由能让其他终端工具完美替代 Windows Terminal。若有 Linux &#x2F; 跨平台需求另说。</p><p><strong>快速安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket add extras<br>scoop install windows-terminal<br></code></pre></td></tr></table></figure><h2 id="终端字体"><a href="#终端字体" class="headerlink" title="终端字体"></a>终端字体</h2><p>我使用 Cascadia Code 在 Nerd Fonts 中的版本。可前往 <a href="https://www.nerdfonts.com/font-downloads">Nerd Fonts</a> 选择其他字体。</p><p>为什么使用 Nerd Fonts？因为提供了更多的图标和字形，在终端中有更丰富的视觉体验。</p><p><strong>快速安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop bucket add nerd-fonts<br>scoop install CascadiaCode-NF-Mono<br></code></pre></td></tr></table></figure><p>在 Windows Terminal 中修改配置 (设置 → 配置文件 → 默认值 → 外观)，即可更换终端字体</p><h2 id="Shell-Prompt"><a href="#Shell-Prompt" class="headerlink" title="Shell Prompt"></a>Shell Prompt</h2><p>Starship 是一款轻量、迅速、客制化的 cross-shell prompt。</p><p>Shell prompt 指的是 CLI 环境中显示的提示信息，比如 Linux 中经典的 sh，它只会显示一个 <code>$</code> 符号，提供的信息非常有限。诸如 Bash，Powershell 等现代 Shell 则通常会显示当前所在的路径，这样就省去了频繁的 <code>pwd</code> 操作。Starship 作为一款 prompt 工具，它可以提供关于当前环境的丰富信息，包括但不限于：命令执行是否成功，命令执行时长，git 仓库信息，开发环境版本等等。此外，starship 还是 “cross-shell” 的，它支持几乎所有 shell，提供了统一的终端体验。</p><p>优点：</p><ul><li>提升可读性</li><li>节省部分操作</li></ul><p>缺点：</p><ul><li>某些情况下，它会自行执行查看当前环境信息，可能会拖慢速度（该工具使用 Rust 开发，可以说在性能方面已经很尽力了）</li></ul><p><strong>快速安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scoop install starship<br></code></pre></td></tr></table></figure><ul><li>Shell 初始化请查阅 <a href="https://starship.rs/guide/#step-2-set-up-your-shell-to-use-starship">官方文档</a></li><li>配置文件默认位于 <code>~/.config/starship.toml</code>，配置请查阅 <a href="https://starship.rs/zh-CN/config/">官方文档</a></li></ul><h2 id="远程主机-SSH-配置"><a href="#远程主机-SSH-配置" class="headerlink" title="远程主机 SSH 配置"></a>远程主机 SSH 配置</h2><p>有了 Windows Terminal，我们也不需要额外的 SSH 客户端程序了。配置新的 SSH 连接非常方便：</p><ol><li>确认 OpenSSH 安装，如果没有就直接 <code>scoop install openssh</code></li><li>确认密钥对，如果没有，使用命令 <code>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code> 生成新的</li><li>将公钥 (文件以 <code>.pub</code> 结尾) 上传至远程主机，可以使用命令 <code>ssh-copy-id -i ~/.ssh/id_ed25519.pub user@123.1.2.3</code></li><li>修改文件 <code>~/.ssh/config</code> 添加新主机信息</li><li>打开 Windows Terminal 添加新的 profile，复制原 PowerShell 配置后将 “命令行” 改为</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">%SystemRoot%\System32\WindowsPowerShell\v1.<span class="hljs-number">0</span>\powershell.exe <span class="hljs-literal">-Command</span> <span class="hljs-string">&quot;ssh serverxyz&quot;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>hostname</code> 就是你在 config 里填入的主机名称。配置文件可以参考这个模版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs test">Host serverxyz<br>  HostName 123.45.67.89<br>  User user<br>  Port 22<br>  IdentityFile ~/.ssh/id_ed25519<br></code></pre></td></tr></table></figure><p>以上步骤完成后，就可以在 Windows Terminal 中一键连接远程主机了。</p><p>如果不想每次登录都手动输入 passphrase，可以按以下步骤操作：</p><p>首先确认 ssh-agent 开启：&#96;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Service</span> ssh<span class="hljs-literal">-agent</span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Service</span> <span class="hljs-literal">-Name</span> ssh<span class="hljs-literal">-agent</span> | <span class="hljs-built_in">Set-Service</span> <span class="hljs-literal">-StartupType</span> Automatic<br></code></pre></td></tr></table></figure><p>然后执行命令将私钥交给它托管：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-add</span> ~\.ssh\id_ed25519<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>terminal</tag>
      
      <tag>windows</tag>
      
      <tag>scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 Kotlin 函数式编程</title>
    <link href="/2024/03/24/intro%20to%20kotlin%20functional%20programming/"/>
    <url>/2024/03/24/intro%20to%20kotlin%20functional%20programming/</url>
    
    <content type="html"><![CDATA[<p>Kotlin 是一门与 Java 兼容、可在 JVM 上运行的编程语言，虽然 Kotlin 整体风格是类似与 Java 的面向对象，但它对函数式编程有非常好的支持。本文分享一些与函数式编程相关的 Kotlin 基础知识。大部分内容均来自 Kotlin 官方文档。</p><h3 id="Lambda-表达式与匿名函数"><a href="#Lambda-表达式与匿名函数" class="headerlink" title="Lambda 表达式与匿名函数"></a>Lambda 表达式与匿名函数</h3><p>在 Kotlin 中， lambda 表达式的语法非常简洁，我们可以省略很多冗余信息。</p><p>以下是一个基本示例，该 lambda 表达式接受两个参数并返回二者的和。在这行代码中，<code>sum</code> 的类型注解是不必要的，Kotlin 能够推断出 lambda 表达式的返回类型是 <code>Int</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br><span class="hljs-comment">// val sum = &#123;x: Int, y: Int -&gt; x + y&#125; 同样正确</span><br><span class="hljs-comment">// println(sum(1, 2)) // 3</span><br></code></pre></td></tr></table></figure><p>Lmabda 表达式常常用作参数，传递给高阶函数使用。当一个 lambda 表达式作为函数实参时，可以省略括号，将花括号写在外面。例如，我们可以使用 <code>any()</code> 来判断一组整数里是否包含偶数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; num: <span class="hljs-built_in">Int</span> -&gt; (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>若 lambda 表达式<strong>仅有一个参数</strong>，那么前面的 <code>-&gt;</code> 可以省略，并且 <code>it</code> 将指代那个参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; (it % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>匿名函数</strong>与 lambda 表达式类似，都用来定义 function literals。二者的主要区别在于匿名函数能够显式地指定返回类型，而 lambda 表达式则不能。lambda 表达式的返回类型只能依靠编译器推断。下面这个例子仍然是 <code>containsEven()</code> 函数，使用了匿名函数语法，不过这里的 <code>Boolean</code> 注解仍然是可以省略的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> isEven = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> collection.any(isEven)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>许多传统 OOP 语言要求函数必须在类内定义，而 Kotlin 则支持多种函数定义，包括：</p><ul><li>Top level function: 直接在文件定义，不依附于类</li><li>Local function: 在函数内定义</li><li>Member function: 在类或匿名类中定义</li><li>Extension function &amp; function with receiver: 在类外定义的函数，可以像使用成员函数一样调用</li></ul><p>Local function 就是函数里的函数。这样的函数能够访问外层函数的所有局部变量。如果将该函数作为返回值，那么将形成闭包 (closure)。这一特性也适用于 lambda 表达式和匿名函数。以下是一个简单的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> ints = listOf(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>ints.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;.forEach &#123; sum += it &#125;<br>print(sum) <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对列表里所有正数求和。这里的 lambda 表达式 <code>&#123; sum += it &#125;</code> 作为参数传给了 <code>forEach</code> 方法，它能够访问外部函数 <code>foo()</code> 的 local variable，得到正确的正数和。</p><p>另一个更复杂的例子来自 Kotlin 官方文档：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(graph: <span class="hljs-type">Graph</span>)</span></span> &#123; <br><span class="hljs-keyword">val</span> visited = HashSet&lt;Vertex&gt;() <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(current: <span class="hljs-type">Vertex</span>)</span></span> &#123; <br><span class="hljs-keyword">if</span> (!visited.add(current)) <span class="hljs-keyword">return</span> <br><span class="hljs-keyword">for</span> (v <span class="hljs-keyword">in</span> current.neighbors)<br>dfs(v) <br>&#125; <br>dfs(graph.vertices[<span class="hljs-number">0</span>]) <br>&#125;<br></code></pre></td></tr></table></figure><p>这里，内部的 <code>dfs()</code> 是一个递归函数，能够访问外部函数的参数 <code>graph</code>，并且可以对集合 <code>visited</code> 进行修改。</p><p>总而言之，<strong>Kotlin 中的内层函数可以访问到外层函数的局部变量，并且可以跨越多层嵌套访问。</strong></p><h3 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h3><p>Kotlin 使用 <code>return</code> 语句来从函数返回。返回值可以留空，空的返回值具有类型 <code>Unit</code>。在嵌套场景下，使用 <code>return</code> 语句的作用是 “returns from the nearest enclosing function or anonymous function”. 简而言之，它会从离它最近的使用 <code>fun</code> 定义的函数返回。</p><p>对于 lambda 表达式而言，情况则稍有不同。Kotlin 编译器会尝试推断 lambda 表达式的函数体是否不返回值，也就是返回值类型为 <code>Unit</code>，如果不是，那么函数体中的最后一个表达式会被自动返回。请看下面这两个 lambda 表达式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func1: () -&gt; <span class="hljs-built_in">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;This function returns nothing?&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> func2: () -&gt; <span class="hljs-built_in">Int</span> = &#123;<br>        println(<span class="hljs-string">&quot;This function return 3&quot;</span>)<br>        <span class="hljs-number">1</span> + <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到，<code>func1</code> 和 <code>func2</code> 都不接受参数，<code>func1</code> 不返回值，而 <code>func2</code> 将返回整数。</p><p>继续使用例子 <code>containsEven()</code>，我们在 <code>.any()</code> 中的 lambda 表达式添加一行打印语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>        collection.any &#123; num -&gt;<br>            <span class="hljs-keyword">val</span> condition = ((num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>            println(<span class="hljs-string">&quot;Number <span class="hljs-variable">$num</span> : <span class="hljs-variable">$condition</span>&quot;</span>)<br>            condition<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里，lambda 表达式的最后一行 <code>condition</code> 会被返回。请注意，这里你不能用 <code>return condition</code> 从 lambda 表达式返回。因为，在 lambda 表达式里使用 <code>return</code> 会跳出 <code>containsEven()</code> 函数，这与预期的功能不符，虽然不会引起编译报错。</p><p>与 lambda 表达式不同的是，匿名函数可以正常使用 <code>return</code> 语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> isEven = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        println(num)<br>        <span class="hljs-keyword">return</span> (num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> collection.any(isEven)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望从 lambda 表达式<strong>显式返回</strong>，我们需要特殊的语法 “return to labels”，以下是一个使用 lambda 表达式的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsEven</span><span class="hljs-params">(collection: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> =  <br>    collection.any &#123; num -&gt;  <br>        <span class="hljs-keyword">val</span> condition = ((num % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)  <br>        println(<span class="hljs-string">&quot;Number <span class="hljs-variable">$num</span> : <span class="hljs-variable">$condition</span>&quot;</span>)  <br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@any</span> condition  <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>高阶函数</strong> (high-order functions) 是将函数作为参数，或将函数作为返回值的函数。</p><p>Kotlin 标准库提供了众多高阶函数，它们能简化代码，提升可读性和可维护性。</p><p>假设你有一个可迭代的容器，里面有很多对象，你希望根据一系列逻辑筛选出符合条件的对象。你可能会写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> results = ArrayList&lt;Item&gt;()  <br><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> items) &#123;  <br>    <span class="hljs-keyword">val</span> condition: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-comment">// 进行一些操作来检查条件</span><br>    <span class="hljs-keyword">if</span> (condition) results.add(item)  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用标准库里的 <code>filter</code> 函数可以简化这样的代码。<code>filter</code> 函数接受一个函数作为参数，并返回一个列表，只包含判断为 true 的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> results = items.filter &#123;<br><span class="hljs-comment">// 使用 it 进行一些操作来检查条件</span><br>condition<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码所示，要使用 <code>filter</code> 函数，可以使用花括号快速创建一个 lambda 表达式。在函数体中，<code>it</code> 将指代 lambda 表达式的唯一参数，并且最后一行将作为返回值返回。</p><p>除此之外，Kotlin 还有许多高阶函数，包括 <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>fold</code>, <code>forEach</code>, <code>sortedBy</code> 等等。配合简洁的 lambda 表达式语法，它们能够简化各类对可迭代对象的操作。</p><h3 id="作用域函数"><a href="#作用域函数" class="headerlink" title="作用域函数"></a>作用域函数</h3><p>作用域函数 (scope functions) 是 Kotlin 提供的一组特殊的高阶函数，你可以在任意对象上调用作用域函数，就像调用成员函数一样。</p><blockquote><p>Kotlin 标准库提供了一些函数，它们用来围绕一个对象执行一段代码块。当你在对象上调用这样的函数，并提供了一个 lambda 表达式时，它形成一个临时作用域。在此作用域中，你可以在不使用对象名称的情况下访问该对象。此类函数称为作用域函数 (scope functions)。共有五个作用域函数：let、run、with、apply 和 also。</p></blockquote><p>上面这段话是 Kotlin 官方对 scope function 的介绍（从英文翻译），是不是很迷糊？我们来看一个例子，该例子使用 <code>StringBuilder</code> 来根据一些数据创建一个字符串。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> builder = StringBuilder()<br>    <span class="hljs-comment">// 从 1 到 10 的字符串</span><br>    builder.append(<span class="hljs-string">&quot;Numbers: &quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) &#123;<br>        builder.append(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> resultString = builder.toString()<br>    println(resultString)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>for</code> 循环可能代表实际代码里的数据处理。在这段代码中，局部变量名称 <code>builder</code> 被重复了很多次，这很繁琐且不美观。我们可以使用函数式编程来改进这段代码的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    StringBuilder().apply &#123;<br>        append(<span class="hljs-string">&quot;Numbers: &quot;</span>)<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) &#123; <br>            append(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <br>        &#125; <br>    &#125;.toString().let &#123;<br>        println(it)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这个 <code>StringBuilder</code> 对象上调用了作用域函数 <code>apply</code>，它接收一个 lambda 表达式。在 lambda 表达式中，我们可以使用 <code>this</code> 来指代原对象，更可以省略 <code>this</code>。我们在结果字符串上继续调用作用域函数 <code>let</code>，并在随后的 lambda 表达式中用参数 <code>it</code> 指代字符串对象。于是，我们就避免了局部变量 <code>builder</code> 和 <code>resultString</code>，从而使代码更加简洁。</p><p>作用域函数的实现方式也非常简单，比如下面这个函数就实现了类似于标准库 <code>apply()</code> 的功能。它用到了 generic function 和 function with receiver 语法，这样允许我们在任何对象上调用它。它接受的参数也是一个 function with receiver，这样就允许我们在 lambda 表达式里使用 <code>this</code> 来指代原对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//                 这里是输入函数的类型</span><br><span class="hljs-comment">//                   ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">myApply</span><span class="hljs-params">(f: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    <span class="hljs-keyword">this</span>.f()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最为相像的四个作用域函数是 <code>let</code>, <code>run</code>, <code>apply</code>, 和 <code>also</code>. 作为扩展函数，它们可以在任意对象上调用，区分它们的要点是：</p><ol><li>是否需要返回对象本身？是否需要返回其他任意值？<code>let</code> 和 <code>run</code> 函数会返回 lambda 表达式的结果，而 <code>apply</code> 和 <code>also</code> 会返回对象本身。</li><li>使用什么引用对象？<code>let</code> 和 <code>also</code> 创造的作用域里使用 <code>it</code> 指代对象，而 <code>apply</code> 和 <code>run</code> 创造的作用域里使用 <code>this</code> 指代对象。</li></ol><p>最后，<code>with</code> 不是一个扩展函数，你需要将对象作为参数传递给它。</p><p>作用域函数的对比表格如下。</p><table><thead><tr><th>Function</th><th>Object reference</th><th>Return value</th><th>Is extension function</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html"><code>let</code></a></td><td><code>it</code></td><td>Lambda result</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html"><code>run</code></a></td><td><code>this</code></td><td>Lambda result</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html"><code>apply</code></a></td><td><code>this</code></td><td>Context object</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html"><code>also</code></a></td><td><code>it</code></td><td>Context object</td><td>Yes</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html"><code>run</code></a></td><td>-</td><td>Lambda result</td><td>No: called without the context object</td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html"><code>with</code></a></td><td><code>this</code></td><td>Lambda result</td><td>No: takes the context object as an argument</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Networkx 中一个引起歧义的参数</title>
    <link href="/2024/02/21/nbunch%20in%20networkx/"/>
    <url>/2024/02/21/nbunch%20in%20networkx/</url>
    
    <content type="html"><![CDATA[<p>安静的夜晚，正准备拉满生产力的我被一个 bug 无情打断。我正在编写一些平凡的数据处理脚本，为了<del>偷懒</del>不重复造轮子，我使用了我并不熟悉的 Python 库 —— networkx. 当我发现处理后的数据和原始数据有不一致的时候，我意识到我写了一个 bug。一番调试之后，我发现这个 bug 来自于一个 API 没有按我猜测的方式工作。</p><p>下面用一个小例子展示一下这个 API 的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx<br>test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>), (<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;101&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>这一行代码使用 networkx 库创建了一个有向图，其节点用字符串表示，初始包含三条边。</p><p>然后，我希望查询某个特定节点的所有出边，通过简单查阅文档，发现了 <code>DiGraph</code> 对象有一个名为 <code>edges</code> 的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># [(&#x27;100&#x27;, &#x27;101&#x27;)]</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;999&#x27;</span>)) <span class="hljs-comment"># []</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;129&#x27;</span>)) <span class="hljs-comment"># [(&#x27;1&#x27;, &#x27;2&#x27;), (&#x27;2&#x27;, &#x27;3&#x27;)]</span><br></code></pre></td></tr></table></figure><p>当填入参数 <code>&#39;100&#39;</code> 时，正确返回了那条以 100 为起始点的边；当填入参数 <code>&#39;999&#39;</code> 时，由于图中没有这个节点，所以返回了一个空列表；当填入参数 <code>&#39;129&#39;</code> 时，它却返回了看似不相干的边。</p><p>这是为什么？？？</p><p>仔细阅读 <code>Digraph.edges</code> 的文档：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;&quot;&quot;An OutEdgeView of the DiGraph as G.edges or G.edges().<br><br>        edges(self, nbunch=None, data=False, default=None)<br><br>        The OutEdgeView provides set-like operations on the edge-tuples<br>        as well as edge attribute lookup. When called, it also provides<br>        an EdgeDataView object which allows control of access to edge<br>        attributes (but does not provide set-like operations).<br>        Hence, `G.edges[u, v][&#x27;color&#x27;]` provides the value of the color<br>        attribute for edge `(u, v)` while<br>        `for (u, v, c) in G.edges.data(&#x27;color&#x27;, default=&#x27;red&#x27;):`<br>        iterates through all the edges yielding the color attribute<br>        with default `&#x27;red&#x27;` if no color attribute exists.<br><br>        Parameters<br>        ----------<br>        nbunch : single node, container, or all nodes (default= all nodes)<br>            The view will only report edges from these nodes.<br>        data : string or bool, optional (default=False)<br>            The edge attribute returned in 3-tuple (u, v, ddict[data]).<br>            If True, return edge attribute dict in 3-tuple (u, v, ddict).<br>            If False, return 2-tuple (u, v).<br>        default : value, optional (default=None)<br>            Value used for edges that don&#x27;t have the requested attribute.<br>            Only relevant if data is not True or False.<br><br>        Returns<br>        -------<br>        edges : OutEdgeView<br>            A view of edge attributes, usually it iterates over (u, v)<br>            or (u, v, d) tuples of edges, but can also be used for<br>            attribute lookup as `edges[u, v][&#x27;foo&#x27;]`.<br><br>        See Also<br>        --------<br>        in_edges, out_edges<br><br>        Notes<br>        -----<br>        Nodes in nbunch that are not in the graph will be (quietly) ignored.<br>        For directed graphs this returns the out-edges.<br><br>        Examples<br>        --------<br>        &gt;&gt;&gt; G = nx.DiGraph()  # or MultiDiGraph, etc<br>        &gt;&gt;&gt; nx.add_path(G, [0, 1, 2])<br>        &gt;&gt;&gt; G.add_edge(2, 3, weight=5)<br>        &gt;&gt;&gt; [e for e in G.edges]<br>        [(0, 1), (1, 2), (2, 3)]<br>        &gt;&gt;&gt; G.edges.data()  # default data is &#123;&#125; (empty dict)<br>        OutEdgeDataView([(0, 1, &#123;&#125;), (1, 2, &#123;&#125;), (2, 3, &#123;&#x27;weight&#x27;: 5&#125;)])<br>        &gt;&gt;&gt; G.edges.data(&quot;weight&quot;, default=1)<br>        OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])<br>        &gt;&gt;&gt; G.edges([0, 2])  # only edges originating from these nodes<br>        OutEdgeDataView([(0, 1), (2, 3)])<br>        &gt;&gt;&gt; G.edges(0)  # only edges from node 0<br>        OutEdgeDataView([(0, 1)])<br><br>        &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>文档表明，当我们给 <code>edges</code> 传 1 个参数时，它实际上是 <code>nbunch</code>，顾名思义，这个 <code>nbunch</code> 就是 a bunch of nodes 一堆节点，它既可以是一个节点，也可以是一个节点的容器，如果不提供参数它将默认为所有节点。在后面的 examples 中，文档展示 <code>G.edges([0, 2])</code> 和 <code>G.edges(0)</code> 两种用法。在 notes 中，文档也提醒我们，不存在的节点会被 quietly ingnored。</p><p>作为历史悠久的 Python 库，networkx 自然是充分利用 Python 的动态特性，并且没有提供任何类型标注，用户并不知道传入 <code>edges</code> 的 <code>nbunch</code> 参数会被当做什么类型。而这个 bug 的原因也非常简单，networkx 库把我们传入的 <code>&#39;129&#39;</code> 当成了一个 iterable 的对象，并试图找到节点 <code>[&#39;1&#39;, &#39;2&#39;, &#39;9&#39;]</code> 为起始的所有边。</p><p>查阅 networkx 的源码，你会发现它没有做任何错事：参数 <code>nbunch</code> 经过 <code>Graph.nbunch_iter()</code> 处理为了一个 iterator，该函数简单地判断 <code>nbunch</code> 是不是当前图里的节点，如果是就返回 <code>iter([nbunch])</code>，如果不是就当成一个节点序列处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nbunch_iter</span>(<span class="hljs-params">self, nbunch=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> nbunch <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># include all nodes via iterator</span><br>        bunch = <span class="hljs-built_in">iter</span>(self._adj)<br>    <span class="hljs-keyword">elif</span> nbunch <span class="hljs-keyword">in</span> self:  <span class="hljs-comment"># if nbunch is a single node</span><br>        bunch = <span class="hljs-built_in">iter</span>([nbunch])<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># if nbunch is a sequence of nodes</span><br>        ...<br>    <span class="hljs-keyword">return</span> bunch<br></code></pre></td></tr></table></figure><p>我想不到这段代码本身有任何问题。但是，当一个对象既可以是一个节点，也有可能是一个可迭代的节点序列，那么这样的 API 调用就是有歧义的。甚至，有向图的点集会影响该 API 的行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)])<br><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># [(&#x27;1&#x27;, &#x27;2&#x27;)]</span><br><br>test_graph.add_nodes_from([<span class="hljs-string">&#x27;100&#x27;</span>]) <span class="hljs-comment"># 仅新增一个节点 不改变原边集</span><br><span class="hljs-built_in">print</span>(test_graph.edges(<span class="hljs-string">&#x27;100&#x27;</span>)) <span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure><p>想要修复也非常简单，只需要手工传入一个长度为 1 的列表即可避免歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">test_graph = nx.DiGraph([(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)])<br><span class="hljs-built_in">print</span>(test_graph.edges([<span class="hljs-string">&#x27;100&#x27;</span>])) <span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure><p>回顾一下这个问题：networkx 在设计之初就借助 Python 的动态特性让它们的 API 尽可能灵活适应不同情况，没有对输入参数的类型进行限制。当用户调用 <code>DiGraph.edges</code> 时，该 API 将输入参数 <code>nbunch</code> 视为何种数据类型由有向图的节点集决定（如果 <code>nbunch</code> 不在点集中则被将视为可迭代对象），在一些情况下，API 的行为和用户的预期产生了偏差，最终导致了隐蔽的 bug。</p><p>实际上，关于 <code>nbunch</code> 参数的歧义，GitHub 社区已经有多个讨论，比如 <a href="https://github.com/networkx/networkx/issues/4781">#4871</a> ， <a href="https://github.com/networkx/networkx/issues/6509">#6509</a> 和 <a href="https://github.com/networkx/networkx/issues/6275">#6275</a> ，社区贡献者也曾积极讨论这个问题，但至今没有引起代码的更改。如果你作为 networkx 的熟练使用者，你很清楚 networkx 会怎么处理 <code>nbunch</code> 参数值，你自然不会写出像 <code>test_graph.edges(node)</code> 的歧义语句。但如果你作为刚刚接触 networkx 的人（就像我一样），则很有可能像我一样直接把节点对象传给该 API。到底要不要为了这个罕见问题修改 networkx 源码，社区开发者最终选择了保持不变。</p><p>那么这样的 bug 该怎么预防呢？或者说，究竟怎么修改 networkx 的代码才能避免这样的潜在 bug 呢？</p><ol><li>加入额外的逻辑判断传入的参数到底是节点序列还是单个节点。然而这是不可能的，因为 networkx 认为所有 hashable 的对象都可以作为节点，并且 networkx 不提供任何节点的基类，并不存在 <code>isinstance(node, BaseNode)</code> 之类的操作。同我们最开始展示的例子，一个 string 既是 hashable 也是 iterable，你没办法仅从数据类型进行判断。</li><li>让 <code>nbunch_iter</code> 只接受 <code>nbunch</code> 是 iterable 对象。这并不会牺牲灵活性，因为当你想传入单个节点时，只需要把它放在一个 list 里就行了。但是这会修改 API，影响到 networkx 库里其他所有用到 <code>nbunch_iter</code> 的地方。</li></ol><p>最终，社区开发者在 <a href="https://github.com/networkx/networkx/pull/6513">这个 PR</a> 里为文档增加了额外的例子来解释 <code>nbunch</code> 可能引起的歧义，而并没有引起代码变更。然而，增加的额外解释藏在 <a href="https://networkx.org/documentation/stable/reference/glossary.html#term-nbunch">Glossary 板块里</a>，极不容易被注意到……</p><p>总而言之，<code>nbunch</code> 的故事就是一个典型的牺牲可靠性获得灵活性的例子，如果 networkx 在设计之初就考虑了 gradual typing，那么 <code>nbunch_iter()</code> 的作者自然不会写出像 <code>Hashable | Iterable[Hashable] | None</code> 或者像 <code>Optional[Union[Hashable, Iterable[Hashable]]]</code> (Python 3.10 之前) 这么奇怪的类型标注，从而在最一开始就把 <code>nbunch</code> 设计为只接受节点序列。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自动化的博客发布工作流</title>
    <link href="/2024/01/12/My%20Blog%20Workflow/"/>
    <url>/2024/01/12/My%20Blog%20Workflow/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>23 年 10 月份，我开始使用 Obsidian 作为笔记工具，从此一发不可收拾。之前氪金支持的 Typora，现在已沦为 Markdown 本地预览器。我进一步发现，Obsidian 透明可定制的设计理念，使它可以与其他工具进行集成和协同，堪称是笔记届的 VSCode。经过 2 天左右的尝试，我就搞出了一套使用 Obsidian 撰写文章并自动发布到网站的工作流，整个过程门槛极低，并且有很不错的自定义空间（假设你非常熟悉前端技术）。现在把这套工具和流程分享给大家。</p><p>目前我使用的工具如下。</p><ul><li><a href="https://docs.github.com/en/pages/quickstart">GitHub Pages</a>: 免费的静态网站部署，大陆可访问</li><li><a href="https://hexo.io/">Hexo</a>: 一个基于 Nodejs 的静态网站生成器，文章使用 Markdown 作为源语言</li><li><a href="https://obsidian.md/">Obsidian</a>: 高度自定义的笔记工具，内容完全基于 Markdown 文件</li><li><a href="https://github.com/denolehov/obsidian-git">Obsidian-Git</a> 插件: 免费的云端备份和跨设备同步解决方案，基于 Git</li></ul><div class="note note-info">            <p>这里一共涉及了三个概念，分别是笔记工具 (编辑 Markdown)、静态网站生成器 (处理 Markdown)、网站部署服务。它们相互独立，分别可以用其他工具替换。本文主要展示我比较喜欢的这一组合。</p>          </div><p>借助这些工具，我们可以在 Obsidian 内随心编写内容，然后自动地将文章发布至网站，并且不会产生任何费用。经过前期的配置后，发布一篇博文真的就<strong>只需要三步</strong>：</p><ol><li>在 Obsidian 里新建文件，填入标题等信息，并在 Obsidian 内完成撰写</li><li>打开命令行执行 <code>hexo deploy -g</code></li><li>等待 GitHub Pages 部署完成，即可在网站上看到精美的文章</li></ol><p>接下来，我简要介绍一下我的配置过程。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了在机器上顺利运行 Hexo 和 Git 等命令行工具，需要提前做以下准备：</p><ol><li>Nodejs. 由于 Hexo 是基于 JavaScript 的工具，需要在自己的机器上安装 node 和 npm&#x2F;pnpm 等命令行工具，Windows 可使用 scoop&#x2F;winget (类似于 Ubuntu 中的 apt) 安装。</li><li>Git. 通过本地的 Git 命令行工具能够直接 pull&#x2F;push 远程仓库，避免手动上传下载。</li><li>GitHub &#x2F; Gitee 等平台账号。<ul><li>我使用 GitHub Pages 作为静态页面部署方案，</li><li>我使用 Gitee 私有仓来托管源码项目，它兼具云端备份和跨设备同步的功能，所以希望网络连接通畅一些，换成 GitHub 也是完全一样的。</li></ul></li></ol><h2 id="Hexo-项目配置"><a href="#Hexo-项目配置" class="headerlink" title="Hexo 项目配置"></a>Hexo 项目配置</h2><p>Hexo 是一个博客站框架，准确的来说，它是一个静态网站生成器，类似于 Jekyll。它负责将一个文件夹 (默认为 <code>source/_posts</code>) 下的所有 Markdown 文件转化为一个网站。关于 Hexo 的用法，可以查阅 <a href="https://hexo.io/docs/">文档</a>。</p><h3 id="创建网站"><a href="#创建网站" class="headerlink" title="创建网站"></a>创建网站</h3><p>首先 clone 官方提供的项目模板到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/hexojs/hexo-starter blog<br></code></pre></td></tr></table></figure><p>进入该路径后，你将会看到：</p><ul><li><code>source/</code> 是存放网站源内容的目录，Hexo 不会修改该目录下的任何内容。准确地来说，该目录中的 Markdown 后缀文件会被 Hexo 识别并处理，其余文件将会照搬至网站文件中。<ul><li><code>source/_posts</code> 中的所有 Markdown 文件将被视作文章，在 Obsidian 中，我们在该文件下创建的笔记将被发布，否则不会被处理为文章。</li></ul></li><li><code>_config.yml</code> 是网站配置，可以根据 <a href="https://hexo.io/docs/configuration">文档</a> 来修改。</li><li><code>themes/</code> 是安装第三方主题的地方。</li><li><code>.gitignore</code> 指定 Git 不会追踪的文件。</li></ul><p>这个目录同时作为 Hexo 项目和 Obsidian Vault，我希望这个目录在我的所有设备之间同步，所以我希望 Git 不要追踪 Node 依赖、Hexo 部署产生的临时文件。这是我的 <code>.gitignore</code> 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gitignore"># Node<br>*.log<br>*.iml<br>node_modules/<br>package-lock.json<br>*.lock<br>pnpm-lock.yaml<br><br># Obsidian<br>.obsidian/workspace.json<br>.obsidian/workspace-mobile.json<br>.obsidian/community-plugins.json<br>.obsidian/plugins/<br><br># Hexo<br>db.json<br>public/<br>.deploy_git/<br></code></pre></td></tr></table></figure><p>在该目录下，使用你喜欢的包管理工具安装依赖，这样你就可以在这个目录下使用 Hexo 命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install<br>npx hexo --version<br></code></pre></td></tr></table></figure><p>至此，你就可以随意使用 Hexo 了。例如你可以使用 <code>hexo generate</code> 来生成整个网站，或者直接使用 <code>hexo server</code> 来在本地浏览器查看网站。在本地查看过程中，你在 <code>source/_posts</code> 修改的文章内容都会立刻生效（浏览器刷新网页）。</p><h3 id="静态网站部署"><a href="#静态网站部署" class="headerlink" title="静态网站部署"></a>静态网站部署</h3><p>接下来，我们可以将 Hexo 生成的网站部署到网上，让其他人都可以看到。使用 GitHub Pages 部署静态网站非常简单，你只需要把网站内容上传到 <code>&lt;username&gt;.github.io</code> 这个仓库，就等同于部署到 <code>https://&lt;username&gt;.github.io</code> 这个网站。</p><p>插件 hexo-deployer-git 可以将上传的流程自动化。首先在该目录下安装 node 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install hexo-deployer-git<br></code></pre></td></tr></table></figure><p>然后在 <code>_config.yml</code> 中填入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;username&gt;/&lt;username&gt;.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><p>这个意思是，告诉 Hexo 你的部署方式是通过 Git 上传到一个你指定的远程仓库。</p><p>前往 GitHub 官网创建一个名为 <code>&lt;username&gt;.github.io</code> 的公开仓库，并参考 <a href="https://docs.github.com/en/pages/quickstart">官方教程</a> 在仓库里设置 Pages 服务，然后你就可以使用 <code>hexo deploy</code> 命令自动上传。一旦你把网站内容传到 GitHub，GitHub Pages 会自动地部署你的内容。</p><h2 id="Obsidian-Vault-配置"><a href="#Obsidian-Vault-配置" class="headerlink" title="Obsidian Vault 配置"></a>Obsidian Vault 配置</h2><p>刚刚讲到，Hexo 本质上就是把 <code>source/_posts</code> 下的所有 Markdown 文件当做文章，并根据它们生成网站。这与 Obsidian 的使用理念高度统一，Obsidian 本质上就是帮助你编辑一个文件夹 (称为 Vault) 下的所有 Markdown 文件。</p><p>我们打开 Obsidian，点击 Open Folder as Vault 并选择我们刚刚创建的目录。这样，Obsidian 会在项目目录下创建一个名为 <code>.obsidian</code> 的文件夹，存放该 Vault 的设置、插件等信息，类似于 <code>.idea/</code> 和 <code>.vscode/</code>。没有特殊情况的话，该文件夹可以让 Git 追踪并同步，不过为了防止潜在的合并冲突，我推荐在 <code>.gitignore</code> 里忽略以下两项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gitignore">.obsidian/workspace.json<br>.obsidian/plugins/<br></code></pre></td></tr></table></figure><h3 id="文章模版"><a href="#文章模版" class="headerlink" title="文章模版"></a>文章模版</h3><p>在 Hexo 中，每个 Markdown 文件都需要通过 front-matter 来指定文章的元信息，一个典型的 front-matter 是这个样子的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;文章标题&quot;</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2024-01-11 11:22:56</span><br><span class="hljs-attr">updated:</span> <span class="hljs-number">2024-01-11 11:22:56</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">文章</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>这些内容会被 Hexo 解析，用于生成网站。完整的设置字段请查阅 <a href="https://hexo.io/docs/front-matter">官方文档</a>。</p><p>也就是说，我们在 Obsidian 中每创建一篇新文章，都需要在最开头附上一段这样的信息。为了节省操作，我推荐使用模版插件来自动生成这样的内容。</p><p>在 Obsidian 设置界面里的 Community Plugins 中搜索 “Templater”，并安装该插件。然后在项目目录下创建一个名为 <code>templater</code> 的空文件夹，并在插件设置中指定该路径为模版文件夹。在 <code>templater</code> 中创建一个新文件（随便起名字），填入以下内容并按需修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;&lt;% tp.file.title %&gt;&#x27;</span><br><span class="hljs-attr">date:</span> &lt;%<span class="language-ruby"> tp.date.now(<span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) </span>%&gt;<br><span class="hljs-attr">updated:</span> &lt;%<span class="language-ruby"> tp.date.now(<span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) </span>%&gt;<br><span class="hljs-attr">categories:</span>  <br><span class="hljs-attr">tags:</span>  <br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>之后，你在任何新笔记中按下 <code>Alt+E</code> 快捷键，就可以得到所需的 front-matter。类似下面这样<br><img src="/attachments/20240112145528.png"></p><p>Obsidian 也是非常给力，这样的 UI 极大增强了可读性，并方便我们编辑相应内容。</p><h3 id="无缝备份-同步"><a href="#无缝备份-同步" class="headerlink" title="无缝备份 &amp; 同步"></a>无缝备份 &amp; 同步</h3><p>我希望我能在任何设备上都能编辑并发布文章，这就需要让这整个项目跨设备同步，这样不管我修改 Hexo 设置，还是添加新文章内容，都没有任何阻碍。下面我介绍我的方案，完全免费。</p><p>在文章的最开始，我们其实就 clone 了一个 Git 仓。这个 Git 仓既追踪 Hexo 项目文件，也追踪了所有 Markdown 源文件。那么我们完全可以借助 Git 来管理目录下一切所需的东西。</p><p>首先，前往 Gitee 创建一个私有仓库，名字无所谓。这个仓库负责托管我们整个项目。</p><p>在项目目录下使用以下命令添加我们刚刚远程仓库（必须是 Obsidian Vault 的根目录，否则自动同步插件不能工作）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://gitee.com/me/repo_name.git<br></code></pre></td></tr></table></figure><p>先手动确认一下 push 没有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;message&quot;</span><br>git push --set-upstream origin master<br></code></pre></td></tr></table></figure><p>以上过程如果要求你在命令行输密码，就不是很方便，我推荐使用 ssh key 或 Git Credential Manager 等方案，这样之后使用插件自动同步就省心了。</p><div class="note note-info">            <p>Tips<br>可以使用 <code>git config commit.gpgsign false</code> 来取消 commit 签名，反正这个项目只在私有仓里备份，并不对其他人可见。</p>          </div><p>确认 Git 可以进行 push&#x2F;pull 操作后，我们使用插件来把同步全自动化。前往 Obsidian 搜索插件 “Obsidian-git” 并安装。</p><ul><li>如果你希望手动同步，那么用快捷键唤起 command palette 后输入 “git” 就可以快速执行各种 git 操作。其中，”Obsidian Git: Create Backup” 命令会保存所有修改、创建 commit、push 到远程仓库，非常实用。</li><li>如果希望自动同步，可以在插件设置中开启 “Auto backup after stopping file edits” 并设置你喜欢的 “Vault backup interval”。</li><li>此外，”Pull updates on startup”, “Push on backup”, 和 “Pull changes before push” 都是很实用的，推荐开启。</li></ul><p>至此，我们先前配置 Hexo 项目、Obsidian Vault 都可以进行自动备份和跨设备同步了。到了新的设备上，我们只需要准备好 nodejs, git, 以及 Obsidian，就不需要再进行配置了，非常方便。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我使用了三个非常 amazing 的工具来帮我自动化发布网站：</p><ul><li>Hexo 可以把一个目录下的所有 Markdown 文件转化为网站文章</li><li>GitHub Pages 可以免费部署静态网站</li><li>Obsidian 提供了完美的撰写体验</li></ul><p>创建新文章并发布的工作流如下：</p><ol><li>打开 Obsidian，在 <code>source/_posts</code> 下创建新笔记</li><li>填写文章标题</li><li>按下快捷键，插入 front-matter 模版，然后按需编辑</li><li>撰写内容，使用 Markdown 书写</li><li>打开命令行，输入 <code>hexo s</code> 预览效果</li><li>打开命令行，输入 <code>hexo deploy -g</code> 发布</li><li>稍等片刻，即可在 <code>https://&lt;username&gt;.github.io</code> 看到新文章~</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试样式</title>
    <link href="/2024/01/11/Test/"/>
    <url>/2024/01/11/Test/</url>
    
    <content type="html"><![CDATA[<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>Here is a PyTorch implementation of Supervised Contrastive Loss, which is proposed by Khosla et al.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Supervised Contrastive Learning. [https://arxiv.org/abs/2004.11362](https://arxiv.org/abs/2004.11362)">[1]</span></a></sup>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Yonglong Tian (yonglong@mit.edu)</span><br><span class="hljs-string">Date: May 07, 2020</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SupConLoss</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Supervised Contrastive Learning: https://arxiv.org/pdf/2004.11362.pdf.</span><br><span class="hljs-string">    It also supports the unsupervised contrastive loss in SimCLR&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, temperature=<span class="hljs-number">0.07</span>, contrast_mode=<span class="hljs-string">&#x27;all&#x27;</span>,</span><br><span class="hljs-params">                 base_temperature=<span class="hljs-number">0.07</span></span>):<br>        <span class="hljs-built_in">super</span>(SupConLoss, self).__init__()<br>        self.temperature = temperature<br>        self.contrast_mode = contrast_mode<br>        self.base_temperature = base_temperature<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, features, labels=<span class="hljs-literal">None</span>, mask=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute loss for model. If both `labels` and `mask` are None,</span><br><span class="hljs-string">        it degenerates to SimCLR unsupervised loss:</span><br><span class="hljs-string">        https://arxiv.org/pdf/2002.05709.pdf</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            features: hidden vector of shape [bsz, n_views, ...].</span><br><span class="hljs-string">            labels: ground truth of shape [bsz].</span><br><span class="hljs-string">            mask: contrastive mask of shape [bsz, bsz], mask_&#123;i,j&#125;=1 if sample j</span><br><span class="hljs-string">                has the same class as sample i. Can be asymmetric.</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            A loss scalar.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        device = (torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>                  <span class="hljs-keyword">if</span> features.is_cuda<br>                  <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>))<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;`features` needs to be [bsz, n_views, ...],&#x27;</span><br>                             <span class="hljs-string">&#x27;at least 3 dimensions are required&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &gt; <span class="hljs-number">3</span>:<br>            features = features.view(features.shape[<span class="hljs-number">0</span>], features.shape[<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>)<br><br>        batch_size = features.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Cannot define both `labels` and `mask`&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            mask = torch.eye(batch_size, dtype=torch.float32).to(device)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            labels = labels.contiguous().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> labels.shape[<span class="hljs-number">0</span>] != batch_size:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Num of labels does not match num of features&#x27;</span>)<br>            mask = torch.eq(labels, labels.T).<span class="hljs-built_in">float</span>().to(device)<br>        <span class="hljs-keyword">else</span>:<br>            mask = mask.<span class="hljs-built_in">float</span>().to(device)<br><br>        contrast_count = features.shape[<span class="hljs-number">1</span>]<br>        contrast_feature = torch.cat(torch.unbind(features, dim=<span class="hljs-number">1</span>), dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> self.contrast_mode == <span class="hljs-string">&#x27;one&#x27;</span>:<br>            anchor_feature = features[:, <span class="hljs-number">0</span>]<br>            anchor_count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.contrast_mode == <span class="hljs-string">&#x27;all&#x27;</span>:<br>            anchor_feature = contrast_feature<br>            anchor_count = contrast_count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Unknown mode: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.contrast_mode))<br><br>        <span class="hljs-comment"># compute logits</span><br>        anchor_dot_contrast = torch.div(<br>            torch.matmul(anchor_feature, contrast_feature.T),<br>            self.temperature)<br>        <span class="hljs-comment"># for numerical stability</span><br>        logits_max, _ = torch.<span class="hljs-built_in">max</span>(anchor_dot_contrast, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>        logits = anchor_dot_contrast - logits_max.detach()<br><br>        <span class="hljs-comment"># tile mask</span><br>        mask = mask.repeat(anchor_count, contrast_count)<br>        <span class="hljs-comment"># mask-out self-contrast cases</span><br>        logits_mask = torch.scatter(<br>            torch.ones_like(mask),<br>            <span class="hljs-number">1</span>,<br>            torch.arange(batch_size * anchor_count).view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).to(device),<br>            <span class="hljs-number">0</span><br>        )<br>        mask = mask * logits_mask<br><br>        <span class="hljs-comment"># compute log_prob</span><br>        exp_logits = torch.exp(logits) * logits_mask<br>        log_prob = logits - torch.log(exp_logits.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>))<br><br>        <span class="hljs-comment"># compute mean of log-likelihood over positive</span><br>        <span class="hljs-comment"># modified to handle edge cases when there is no positive pair</span><br>        <span class="hljs-comment"># for an anchor point. </span><br>        <span class="hljs-comment"># Edge case e.g.:- </span><br>        <span class="hljs-comment"># features of shape: [4,1,...]</span><br>        <span class="hljs-comment"># labels:            [0,1,1,2]</span><br>        <span class="hljs-comment"># loss before mean:  [nan, ..., ..., nan] </span><br>        mask_pos_pairs = mask.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br>        mask_pos_pairs = torch.where(mask_pos_pairs &lt; <span class="hljs-number">1e-6</span>, <span class="hljs-number">1</span>, mask_pos_pairs)<br>        mean_log_prob_pos = (mask * log_prob).<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>) / mask_pos_pairs<br><br>        <span class="hljs-comment"># loss</span><br>        loss = - (self.temperature / self.base_temperature) * mean_log_prob_pos<br>        loss = loss.view(anchor_count, batch_size).mean()<br><br>        <span class="hljs-keyword">return</span> loss<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Supervised Contrastive Learning. <a href="https://arxiv.org/abs/2004.11362">https://arxiv.org/abs/2004.11362</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
